{"meta":{"title":"AT Team","subtitle":null,"description":null,"author":"AT Team","url":"https://hieunh161.github.io"},"pages":[{"title":"about","date":"2016-10-20T14:44:15.000Z","updated":"2016-10-22T07:41:46.412Z","comments":true,"path":"about/index.html","permalink":"https://hieunh161.github.io/about/index.html","excerpt":"","text":"Team AT = Advance Technology TeamĐây là hình ảnh của team chúng tôi."}],"posts":[{"title":"The mythical men-day (Phần 1)","slug":"productivity-1","date":"2016-10-22T15:38:01.000Z","updated":"2016-10-22T17:31:56.377Z","comments":true,"path":"2016/10/23/productivity-1/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/23/productivity-1/","excerpt":"Lời nói đầuThế kỷ 21 sẽ là thế kỷ của hội nhập nơi tất cả các quốc gia các tổ chức, các công ty cùng bắt đầu chơi trên một sân khấu lớn, một sân khấu chung, một thế giới phẳng. Những câu chuyện về toàn cầu hóa, về outsourcing là những chủ đề nổi bật trong 2 thập niên gần đây. Trong tiến trình đó có rất nhiều cơ hội mới nhưng đồng thời có vô vàn thách thức và áp lực. Các công ty nước ngoài vào Việt Nam như thổi luồng gió mới với khu vực FDI nhưng nó cũng thách thức các doanh nghiệp nội vốn dĩ quen với làm ăn bao cấp, cơ chế cần phải đổi mới đẩy mạnh các hoạt động cải tiến để có thể đạt được vị trí vững chắc trên thị trường. Theo michael porter , giáo sư đại học Havard và được xem là cha đẻ chiến lược cạnh tranh hiện đại ông đã đề cập tới 2 yếu tố được xem như là xương sống của bất kỳ sự thành công của doanh nghiệp và tổ chức nào đó chính là hoạt động sản xuất hiệu quả (Operation effective – OE) và chiến lược cạnh tranh (Strategy).","keywords":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"text":"Lời nói đầuThế kỷ 21 sẽ là thế kỷ của hội nhập nơi tất cả các quốc gia các tổ chức, các công ty cùng bắt đầu chơi trên một sân khấu lớn, một sân khấu chung, một thế giới phẳng. Những câu chuyện về toàn cầu hóa, về outsourcing là những chủ đề nổi bật trong 2 thập niên gần đây. Trong tiến trình đó có rất nhiều cơ hội mới nhưng đồng thời có vô vàn thách thức và áp lực. Các công ty nước ngoài vào Việt Nam như thổi luồng gió mới với khu vực FDI nhưng nó cũng thách thức các doanh nghiệp nội vốn dĩ quen với làm ăn bao cấp, cơ chế cần phải đổi mới đẩy mạnh các hoạt động cải tiến để có thể đạt được vị trí vững chắc trên thị trường. Theo michael porter , giáo sư đại học Havard và được xem là cha đẻ chiến lược cạnh tranh hiện đại ông đã đề cập tới 2 yếu tố được xem như là xương sống của bất kỳ sự thành công của doanh nghiệp và tổ chức nào đó chính là hoạt động sản xuất hiệu quả (Operation effective – OE) và chiến lược cạnh tranh (Strategy). Trong những năm 1970, 1980 của thế kỷ trước với trái tim là hoạt động sản xuất hiệu quả Nhật Bản đã thách thức các công ty phương tây với các khái niệm như quản lý chất lượng toàn diện (total quality management), liên tục đánh giá cải tiến (benchmarking), sử dụng thời gian hiệu quả (time-based competition), sản xuất tinh gọn (lean production development) … Và với những điều đã làm họ đã từng vượt xa các đối thủ cạnh tranh của mình về mặt OE khiến người Nhật có thể đưa ra các sản phẩm giá rẻ hơn và có chất lượng tuyệt hảo trong cùng thời gian. Nói về chiến lược cho công ty đó là câu chuyện khó, và để định hướng cho một công ty có thể đi đúng hướng thì trách nhiệm phần lớn thuộc về những nhà quản trị cấp cao, những top-level manager, thế nhưng nói về OE thì đó là câu chuyện của cả công ty, nó không chỉ là vấn đề của các nhà quản trị cấp dưới là những nhà quản trị cấp trung (middle-level manager) và cấp cơ sở (first-level manager) mà nó còn là vấn đề của chính các nhân viên. Khi mỗi người có ý thức nhất định về hoạt động sản xuất kinh doanh hiệu quả thì chắc chắn rằng không có lý do gì để công ty đó không đạt hiệu quả cao ít nhất về mặt chất lượng và sản lượng. Những năm gần đây, khi mà lợi thế về nhân công giá rẻ ở Việt Nam đã dần trở nên bão hòa, nền kinh tế phát triển chậm lại vì sự thiếu ổn định vĩ mô. Các lợi thế do tài nguyên thiên nhiên ưu đãi đã dần mất đi thì vấn đề hiệu suất, năng suất công việc của người Việt đã trở thành một vấn đề quan trọng, quyết định tới sự phát triển tương lai của cả đất nước. Khi hội nhập người Việt Nam luôn nghĩ rằng giá rẻ là một lợi thế cạnh tranh, đó là điều đúng, thế nhưng chúng ta không thể lấy đó là niềm tự hào, phải tự hỏi rằng tại sao giá chúng ta lại rẻ. Ở các nước tiên tiến, năng suất lao động của họ cao gấp hơn 100 lần người Việt, ngay cạnh chúng ta các nước như Thái Lan hay Malaysia cũng có năng suất cao hơn chúng ta 20,30 lần. Vậy chúng ta phải đặt câu hỏi rằng, tại sao và tại sao? Các nhà nghiên cứu đã thống nhất rằng, trong thế kỷ 21 khi mà nguồn tài nguyên hóa thạch dần cạn kiệt thì tài nguyên lớn nhất của xã hội sẽ nằm ở con người, xã hội nào phát triển được điều đó đồng nghĩa với việc sẽ chiếm được ưu thế trong tương lai. Giá trị của chất xám là điều không cần bàn cãi khi con người trong thế kỷ 20 đã khám phá ra vô số các phát minh có giá trị thúc đẩy công nghệ và khoa học kỹ thuật. Và chính bản thân các nước phát triển ngày nay cũng đã chứng minh điều đó. Nhật Bản một nước nghèo nàn về tài nguyên nhưng nhờ đầu tư khoa học kỹ thuật con người đã trở thành siêu cường của thế kỷ 20, Mỹ với triết lý tự do, khuyến khích sự sáng tạo vẫn luôn đi đầu trong tất cả các lĩnh vực then chốt của nhân loại trong thế kỷ qua. Hàn Quốc một quốc gia nghèo nàn về tài nguyên so với người anh em Triều Tiên của mình nhưng lại có nền khoa học phát triển vượt bậc, có các công ty lớn nhất thế giới như Samsung, huyndai, tất cả dựa vào yếu tố con người. Trong chuyên đề tìm hiểu về hoạt động kinh doanh sản xuất này, tôi muốn đi tìm những điều ẩn chứa đằng sau thành công của quá trình hoạt động sản xuất hiệu quả. Những yếu tố làm tăng năng suất lao động, những điều có thể áp dụng và thay đổi một tổ chức để có thể thúc đẩy một tổ chức đi tới thành công. Đó có thể chỉ là những yếu tố rất nhỏ, những điều tôi lượm lặt được trên con đường tích lũy tri thức của bản thân mình, đó có thể là những lời khuyên từ những chuyên gia, những điều đến từ các kết quả nghiên cứu của các tổ chức trên thế giới. Thế nhưng dù nó là cái gì thì đó cũng là những điều tôi tin rằng sẽ góp phần tăng hoạt động hiệu quả của các tổ chức, ít nhất là trong lĩnh vực công nghệ thông tin, lĩnh vực tôi đang làm việc. Kaizen vs innovationTrong lĩnh vực sản xuất, mục đích của các công ty luôn làm sao để có thể tối ưu hóa hoạt động của mình để có thể đạt được chất lượng tốt nhất và đồng thời đạt được sản lượng cao nhất. Một công ty chỉ có thể vượt trên đối thủ của mình nếu họ có thể đạt được sự khác biệt và bảo tồn được sự khác biệt đấy. Đồng thời họ phải cung cấp được cho người dùng sản phẩm với giá trị cao hơn đối thủ hoặc chí ít ở một mức cạnh tranh được đồng thời phải ở một cái giá thấp nhất có thể. Đó là một mối tổng thể kết hợp của rất nhiều các khâu các yếu tố từ không chỉ từ các khâu cơ bản nghiên cứu, chế tạo, bán, phân phối sản phẩm hoặc dịch vụ, mà đó còn là từ chăm sóc khách hàng, đào tạo nhân viên, tạo ra những giá trị thặng dư ngoài sản phẩm…Trong lĩnh vực IT một ví dụ nổi tiếng về sự khác biệt quá nổi tiếng mà bất kỳ ai cũng có thể nhận ra đó là ví dụ của Apple. Quả táo khuyết đã quyết định đi theo con đường riêng của mình ngay từ những ngày đầu với hệ điều hành MAC. Và chính điều đó đã làm nên sự đọc đáo của apple mà không một công ty nào có thể bắt trước được. Với apple đó không chỉ là những sản phẩm tuyệt vời, nó còn là duy nhất. Họ đã thành công với triết lý tạo nên sự khác biệt và mang đến cho người dùng không chỉ sản phẩm mà trên đó nữa đó là sự trải nghiệm. Câu chuyện OE là một câu chuyện rất dài, nó đi theo xuyên suốt chiều dài của sản xuất, kinh doanh từ khi con người biết cách chuyển lao động hái lượm săn bắt về trồng trọt. Qua quá trình lao động họ không những tìm ra những điều mới mà họ còn phải cố gắng giảm thiểu những sự lãng phí …Ngày nay nó gắn với bất kỳ hoạt động nào mà cho phép các công ty tổ chức tận dụng tối đa các tài nguyên đầu vào, giảm thiểu các lỗi trên sản phẩm, trong sản xuất, phát triển sản phẩm tốt hơn và nhanh hơn. Quá trình này rất đa dạng và mỗi tổ chức đều tìm cho mình một cách khác nhau để thực hiện nó, có những công ty cố gắng giảm thiểu sự lãng phí để có thể cho ra nhiều sản phẩm hơn với lượng đầu vào đã có, có những công ty cố gắng ứng dụng nhiều công nghệ hơn, có những công ty cố gắng tạo động lực lớn hơn cho nhân viên của mình, có những công ty lại cố gắng tập trung vào việc quản lý chặt chẽ để đưa ra một quy trình tối ưu hơn …Tất cả các quá trình đó với một mục đích cuối cùng là tạo ra những sản phẩm tuyệt vời với giá cả thấp nhất. Người Nhật nổi tiếng với hoạt động kaizen còn Mỹ và phương tây nổi tiếng với khái niệm innovation. Cả hai thuật ngữ đều ám chỉ các hoạt động dùng để cả thiện hoạt động sản xuất của doanh nghiệp. Vậy có điểm gì khác nhau giữa hai khái niệm này. Trong tiếng anh kaizen được dịch là continuous improvement, một cách đơn giản chúng ta có thể hiểu rằng kaizen(改善) là hoạt động cải tiến liên tục dựa vào việc nhận ra các vấn đề của công việc, cải tiến, áp dụng vào thực tế. Lặp đi lặp lại liên tục để không ngừng gia tăng hiệu quả công việc. Innovation là đổi mới, nghĩa là áp dụng các cách thức thay đổi lớn mang tính nhảy vọt nhằm đạt được được bước nhảy vọt về chất lượng của như sản lượng. Một cách mô hình chúng ta có thể hiểu kaizen của người Nhật như là một chú rùa lầm lũi cần mẫn và không ngừng bước tới, còn đối với innovation của phương tây như là một chú thỏ, có thể bước những bước rất dài để tới đích. Chúng ta có thể hình dung Kaizen như là một quá trình đi lên không ngừng nghỉ, còn innovation là một quá trình bậc thang, thay đổi theo các bậc. như hình dưới đây. Kaizen có ảnh hưởng trong dài hạn và tồn tại lâu tuy nhiên ảnh hưởng của nó thường không bao giờ quá lớn. Còn đối với innovation nó xảy ra trong thời gian ngắn tuy nhiên ảnh hưởng lại vô cùng mạnh mẽ. Sức mạnh của kaizen nằm ở việc liên tục cải tiến, tuy từ từ từng chút một nhưng nó ổn định. Đồng thời có sự tham gia của tất cả các thành phần trong tổ chức, từ cấp quản lý cho tới từng nhân viên. Chính vì thế khi áp dụng kaizen kết quả thu được luôn là một tập thể mạnh. Ngược lại với innovation, nó là quá trình xảy ra đứt quãng, thay đổi mạnh mẽ, tuy nhiên nó thường xuất phát từ một vài cá nhân giỏi kiệt xuất với những ý tưởng mới mẻ như là những mũi nhọn và dần dần lan ra rộng khắp trong tổ chức. Tuy nhiên đôi khi đổi mới không phải xuất phát từ sự tự phát mà nó xuất phát từ tình thế cần phải yêu cầu sự thay đổi. Ví dụ như sau một thời gian dài làm việc, chất lượng đi xuống, nhân viên bắt đầu thiếu động lực…hay bị các đối thủ cạnh tranh vượt lên trong cuộc đua thị phần, chất lượng. Lúc này các nhà quản lý mới thấy cần có sự thay đổi và họ bắt đầu cải tiến. Vì thế các tổ chức áp dụng innovation trong các giai đoạn tái cấu trúc, hoặc khi có cần sự đột phá cao để đạt được các mục tiêu lớn. Còn hoạt động kaizen luôn hướng tới việc phát triển bền vững. Cũng do đặc thù cần có sự đột phá lớn nên các hoạt động innovation luôn cần có một sự đột phá về mặt công nghệ, một lý thuyết mới hay một phát minh mới. Ngược lại quá trình kaizen nhấn mạnh vào kỹ năng làm việc, vào các kiến thức hàng ngày, và một nền tảng tri thức tích lũy. Hoạt động kaizen nhấn mạnh vào yếu tố con người, thông qua lao động sản xuất hàng ngày để đạt được kết quả cao. Còn bản thân innovation nhấn mạnh vào yếu tố công nghệ, lấy công nghệ làm trung tâm là yếu tố then chốt để tổ chức vươn mình đi trước các đối thủ. Cũng chính từ những đặc điểm này mà hoạt động kaizen phù hợp với một thị trường phát triển không quá nhanh, một nền kinh tế ổn định. Còn bản thân innovation là hoạt động mang tính đột phá, nó phù hợp với một nền kinh tế tăng trưởng nhanh và năng động. Michael porter cũng đã nhắc tới yếu tố này trong cuốn sách của ông với việc nhấn mạnh các công ty Nhật sau một thời gian đi đầu trong các lĩnh vực đang dần trở nên chậm chạp và bị các công ty phương Tây vượt lên trong một nền kinh tế phẳng nơi mà yếu tố chiến lược và đổi mới là những yếu tố quyết định sự thành công. Bản thân phương tây cũng học được rất nhiều điều từ khái niệm kaizen của người Nhật, đến mức hiện tại kaizen đã trở thành một từ xuất hiện trong từ điển tiếng anh với khái niệm cải tiến trong hoạt động sản xuất. Với các nghiên cứu về hoạt động kaizen của người Nhật, phương tây cũng đã thu được rất nhiều kinh nghiệm quý báu. Những cuốn sách như toyota way, how to do kaizen, kaizen guide … lần lượt là những cuốn sách best seller và đã được phương tây đón nhận nồng nhiệt. Ở Việt Nam có cuốn sách kaizen teian được Hiệp hội con người Nhật Bản giới thiệu đã được dịch sang tiếng Việt cũng là một cuốn sách hay về kaizen. Ở khía cạnh ngược lại, người Nhật sau một thời gian dài thụt lùi đã nhận ra rằng họ cần phải thay đổi, với các phương thức cũ đã không thể giữ họ ở vị trí đỉnh cao của thế giới và họ cũng đang dần chuyển mình. Họ nhận ra rằng họ phải đổi mới nhiều hơn để có thể có những sản phẩm đỉnh cao như trước đây họ đã có. Dần dần các doanh nghiệp, các tổ chức hiện đại dung hòa hai khái niệm này và đưa ra một mô hình phát triển hoàn thiện hơn cho doanh nghiệp của mình như hình trên, đó là sự kết hợp giữa kaizen và innovation, đó là một mô hình giúp các doanh nghiệp có thể đạt được sự phát triển bền vững và ổn định dựa vào cả hai mũi nhọn. Tối ưu hóa hoạt động sản xuất và nhảy vọt nhờ vào sáng tạo công nghệ. Các nhà nghiên cứu cũng chỉ ra rằng trong chuỗi sản xuất sản phẩm thì sẽ có những giai đoạn cần thiên hướng và đổi mới và có những giai đoạn cần phải tập trung tối đa vào kaizen. Ví dụ như những giai đoạn cần hiệu quả cao trong tổ chức, thực hành như hoạt động tại các công xưởng, nhà máy thì lúc này các nhà quản trị cần phải tối ưu hóa vào việc tổ chức các hoạt động kaizen. Các số liệu của các công ty Nhật đã cho thấy rằng, trung bình những công ty hoạt động kaizen hiệu quả 1 năm trung bình mỗi người có khoảng hàng chục kaizen giúp doanh nghiệp hoạt động hiệu quả hơn. Người Nhật luôn có suy nghĩ tích tiểu thành đại, ví dụ mỗi người tiết kiệm được 5 phút/ngày thì cả doanh nghiệp 1000 người có thể tiết kiệm được 5000 phút/ngày = 10 ngày làm việc, 1 năm sẽ tiết kiệm được 2000 ngày công, đó là một con số không hề nhỏ. Thế nên mỗi sáng kiến kaizen chỉ cần tiết kiệm được 1 phút thì đó là một con số khổng lồ. Ngược lại có những hoạt động đòi hỏi tính đối mới sáng tạo cao. Như các hoạt động nghiên cứu sản phẩm mới, các hoạt động mang tính ý tưởng chiến lược, thì lúc đó cần phát huy tối đa tính sáng tạo của nhân viên. Hiện nay ở lĩnh vực công nghiệp phần mềm có thể chia làm 2 lĩnh vực chính là sản xuất sản phẩm như vinagame hay outsourcing như Fsoft thì với mỗi công ty đặc thù cần phải nhấn mạnh vào những khía cạnh khác nhau. Các công ty tự sản xuất sản phẩm thường phải có tỷ lệ đổi mới/cải tiến là 7/3 và với các công ty gia công phần mềm là ngược lại 3/7. Bởi vì bản thân gia công phần mềm tính chất đổi mới bị hạn chế rất nhiều do phần lớn các công nghệ, các yêu cầu tới từ phía đối tác, các khách hàng nước ngoài, và việc lớn nhất các công ty phần mềm gia công cần làm đó là làm thế nào để đưa ra sản phẩm với chất lượng tốt nhất dựa vào những yêu cầu cụ thể đó. Ngược lại các công ty tự sản xuất cần phải áp dụng các công nghệ mới nhất tốt nhất để có thể đưa ra những sản phẩm có tính cạnh tranh cao trong thị trường IT khắc nghiệt. Nhưng dù thế nào đi nữa thì các hoạt động để cải tiến, cải tiến và không ngừng nâng cao luôn là điều bắt buộc nếu một công ty một tổ chức muốn giữ vị thế cạnh tranh của mình trước các đối thủ bám đuôi phía sau. Muốn cho công ty liên tục tồn tại và phát triển trường tồn thì đây sẽ là kim chỉ nam để các công ty hướng tới. Không ngừng hoàn thiện, cải tiến và phát triển. Đó có thể là bất cứ yếu tố nào mang lại hiệu ứng tích cực cho công ty ví dụ như cải tiến trong sản xuất, trong phương pháp làm việc, cũng như là cải tiến trong văn hóa, trong ứng xử để gắn kết nhân viên với nhau cũng như công ty với nhân viên.…","categories":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"tags":[{"name":"productivity","slug":"productivity","permalink":"https://hieunh161.github.io/tags/productivity/"}]},{"title":"Những điểm mới trong ES6 (Phần 2)","slug":"javascript-es6-2","date":"2016-10-22T09:55:40.000Z","updated":"2016-10-22T13:05:28.121Z","comments":true,"path":"2016/10/22/javascript-es6-2/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/22/javascript-es6-2/","excerpt":"ClassMột trong những tính năng được mong chờ nhất trong javascript chính là class. Mặc dù trên ES5 chúng ta có thể tạo được class, tuy nhiên đó là một cách không dễ dàng đối với những người mới bắt đầu code javascript. Với ES6 mọi thứ trở nên rất dễ dàng: 1234567891011class Pony &#123; constructor(color) &#123; this.color = color; &#125; toString() &#123; return `$&#123;this.color&#125; pony`; // 'template literals' là một tính năng rất hay khác nữa trong ES6 &#125;&#125;const bluePony = new Pony('blue');console.log(bluePony.toString()); // blue pony","keywords":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"text":"ClassMột trong những tính năng được mong chờ nhất trong javascript chính là class. Mặc dù trên ES5 chúng ta có thể tạo được class, tuy nhiên đó là một cách không dễ dàng đối với những người mới bắt đầu code javascript. Với ES6 mọi thứ trở nên rất dễ dàng: 1234567891011class Pony &#123; constructor(color) &#123; this.color = color; &#125; toString() &#123; return `$&#123;this.color&#125; pony`; // 'template literals' là một tính năng rất hay khác nữa trong ES6 &#125;&#125;const bluePony = new Pony('blue');console.log(bluePony.toString()); // blue pony class trong javascript không giống biến var, khi chúng ta bắt buộc phải khai báo nó trước khi sử dụng. Bạn sẽ nhận ra hàm rất đặc biệt là constructor. Hàm này sẽ được gọi khi chúng ta dùng toán tử new để khởi tạo đối tượng.Tương tự như các ngôn ngữ khác, ES6 cho phép khai báo static bên trong class. Với hàm hoặc thuộc tính được khai báo static, chúng ta có thể truy cập trực tiếp mà không cần khởi tạo đối tượng. 123456class Pony &#123; static defaultSpeed() &#123; return 10; &#125;&#125;const speed = Pony.defaultSpeed(); Nếu bạn là tín đồ của hướng đối tượng, chắc chắn bạn sẽ mong muốn các tính năng khác như set, get, kế thừa … ES6 cung cấp đầy đủ điều đó. Khi chúng ta muốn get/set: 12345678910111213141516class Pony &#123; get color() &#123; console.log('get color'); return this._color; &#125; set color(newColor) &#123; console.log(`set color $&#123;newColor&#125;`); this._color = newColor; &#125;&#125;const pony = new Pony();pony.color = 'red';// 'set color red'console.log(pony.color);// 'get color'// 'red' Kế thừa trong ES6 như sau: 123456789class Animal &#123; speed() &#123; return 10; &#125;&#125;class Pony extends Animal &#123;&#125;const pony = new Pony();console.log(pony.speed()); // 10, as Pony kế thừa method lớp cha Bạn có thể override method cha như bất kỳ ngôn ngữ hướng đối tượng thông thường nào khác. 123456789101112class Animal &#123; speed() &#123; return 10; &#125;&#125;class Pony extends Animal &#123; speed() &#123; return super.speed() + 10; &#125;&#125;const pony = new Pony();console.log(pony.speed()); // 20, as Pony overrides the parent method Javascript có vẻ đã trở nên rất giống Java khi chúng ta cũng có thể sử dụng từ khóa super để gọi các hàm của lớp cha. PromisesPromise không phải tính năng quá mới mẻ, nó đã có trong Angular1 và nếu bạn đã từng code Angular2 thì chắc không quá xa lạ với khái niệm này.Mục đích của Promise là làm đơn giản việc lập trình không đồng bộ (Asynchronous). Chúng ta thường sử dụng callback để xử lý kết quả trả về trong ES5 khi muốn thực hiện sử lý không đồng bộ như AJAX. Promise giúp chúng ta làm phẳng code, dễ dàng trong việc đọc và bảo trì code hơn. Hãy xem ví dụ sau khi thực hiện với callback và với Promise. Với callback: 12345getUser(login, function (user) &#123; getRights(user, function (rights) &#123; updateMenu(rights); &#125;);&#125;); Với Promise: 1234567getUser(login) .then(function (user) &#123; return getRights(user); &#125;) .then(function (rights) &#123; updateMenu(rights); &#125;) Mặc định Promise có thể hiểu là một đối tượng thenable nghĩa là nó có hàm then . Hàm này sẽ nhận hai tham số, một xử lý khi thành công và một cho thất bại. Promise có 3 thành phần sau: pending: Khi promise chưa hoàn thành fulfilled: Khi promise thực hiện thành công rejected: Khi promise thực hiện thất bại Khi promise được fulfilled thì hàm success sẽ được gọi, và ngược lại khi rejected thì hàm xử lý lỗi sẽ được gọi.Vậy làm thế nào để gọi Promise? Chúng ta chỉ đơn giản khởi tạo một đối tượng có tên Promise. Hàm này sẽ nhận 2 tham số callback như đã nói ở trên, một cho thành công, một cho thất bại. 12345678910const getUser = function (login) &#123; return new Promise(function (resolve, reject) &#123; // async stuff, like fetching users from server, returning a response if (response.status === 200) &#123; resolve(response.data); &#125; else &#123; reject('No user'); &#125; &#125;);&#125;; Khi khai báo như trên xong chúng ta có thể sử dụng getUser với hàm then. Trong trường hợp chỉ muốn xử lý thành công chúng ta có thể bỏ qua biến reject như dưới. 1234getUser(login) .then(function (user) &#123; console.log(user); &#125;) Điểm hay của Promise như đã nói ở trên đó là nó làm phẳng code của chúng ta. Trong trường hợp chúng ta có nhiều callback lồng nhau thông thường chúng ta có thể viết: 1234567getUser(login) .then(function (user) &#123; return getRights(user) // getRights is returning a promise .then(function (rights) &#123; return updateMenu(rights); &#125;); &#125;) Nhưng với promise chúng ta có thể viết một cách đẹp đẽ hơn thế. 1234567getUser(login) .then(function (user) &#123; return getRights(user) // getRights is returning a promise &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;); Một điểm thú vị nữa đó là hàm xử lý lỗi, chúng ta có thể viết riêng cho từng promise, nhưng cũng có thể gộp chung cho một chuỗi promise như sau:Xử lý lỗi cho từng promise 12345678910111213getUser(login) .then(function (user) &#123; return getRights(user); &#125;, function (error) &#123; console.log(error); // xử lý cho getUser failed return Promise.reject(error); &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;, function (error) &#123; console.log(error); // xử lý cho getRights failed return Promise.reject(error); &#125;) Xử lý lỗi chung có các promise với catch 12345678910getUser(login) .then(function (user) &#123; return getRights(user); &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;) .catch(function (error) &#123; console.log(error); // Xử lý lỗi chung khi có một xử lý trong chuỗi lỗi &#125;) Arrow functionsĐây là một trong những tính năng cá nhân mình thích nhất của ES6. Sử dụng hàm mũi tên sẽ vô cùng tiện dụng trong nhiều trường hợp. Quay trở lại với ví dụ về Promise phía trên ta có: 1234567getUser(login) .then(function (user) &#123; return getRights(user); // getRights is returning a promise &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;) Khi sử dụng cú pháp arrow chúng ta có thể viết lại như sau: 123getUser(login) .then(user =&gt; return getRights(user))// getRights is returning a promise .then(rights =&gt; return updateMenu(rights)) Rất đẹp phải không nào.Tôi đã không nói nên lời khi lần đầu tiên sử dụng cú pháp này trong dự án của mình. Bởi vì nó làm cho code trở nên vô cùng đẹp. Chúng ta phải chú ý là khi giá trị trả về là một block code chúng ta cần có ngoặc đơn như sau: 123456getUser(login) .then(user =&gt; &#123; console.log(user); return getRights(user); &#125;) .then(rights =&gt; updateMenu(rights)) Cú pháp arrow không chỉ giúp cho việc code trở nên đơn giản hơn mà nó còn có một đặc điểm rất quan trọng sau.Lấy ví dụ đoạn code sau: 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Đoạn code trên sẽ không chạy như bạn mong đợi. Bởi vì this trong javascript sẽ trỏ tới đối tượng đang được tương tác.Tuy nhiên trong trường hợp này khi sử dụng hàm anonymous trong hàm forEach thì biến this sẽ được trỏ tới Window. Tất nhiên chúng ta có thể fix vấn đề này một cách đơn giản bằng việc gán lại biến this cho một biến khác để đảm bảo trỏ đúng tới đối tượng mong muôn: 1234567891011121314151617var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate var self = this; numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; self.max) &#123; self.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Hoặc có thể sử dụng hàm bind để gắn con trỏ this vào. 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;.bind(this)); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Thậm chí có thể truyền trực tiếp biến this như một tham số thứ 2 cho hàm forEach 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;, this); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Với ES6 mọi thứ trở nên dễ dàng hơn với arrow function: 12345678910111213const maxFinder = &#123; max: 0, find: function (numbers) &#123; numbers.forEach(element =&gt; &#123; if (element &gt; this.max) &#123; this.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Sets and MapsVới ES6 chúng ta có thêm các kiểu dữ liệu collection là Set và Map. Bạn nào từng làm Java sẽ thích điều này. Ví dụ về Map: 123456const cedric = &#123; id: 1, name: 'Cedric' &#125;;const users = new Map();users.set(cedric.id, cedric); // adds a userconsole.log(users.has(cedric.id)); // trueconsole.log(users.size); // 1users.delete(cedric.id); // removes the user Ví dụ về Set 123456const cedric = &#123; id: 1, name: 'Cedric' &#125;;const users = new Set();users.add(cedric); // adds a userconsole.log(users.has(cedric)); // trueconsole.log(users.size); // 1users.delete(cedric); // removes the user Cuối cùng như bao collection khác, chúng ta có thể loop thông qua for … of 123for (let user of users) &#123; console.log(user.name);&#125; Template literalsNối string luôn là một chuyện rườm rà trong javascript. Chúng ta thông thường sẽ làm: 1const fullname = 'Miss ' + firstname + ' ' + lastname; Nhưng với chức năng template literal thì mọi chuyện sẽ trở nên dễ dàng hơn nhiều 1const fullname = `Miss $&#123;firstname&#125; $&#123;lastname&#125;`; Và thậm chí nó còn trở nên hữu ích hơn rất nhiều khi nó hỗ trợ chức năng multi line. 123const template = `&lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;/div&gt;`; ModulesModule là một chức năng còn thiếu của javascript cho tới ES5. Khi chúng ta muốn tổ chức code, chúng ta đều phải sử dụng các third party như RequireJs.ES6 cung cấp thêm chức năng module và các cú pháp cho phép chúng ta import/export thông tin từ các modules. Mặc định mỗi file là một module riêng biệt trong ES6. File races_service.js123456export function bet(race, pony) &#123; // ...&#125;export function start(race) &#123; // ...&#125; Với từ khóa export chúng ta export 2 hàm, và ở một file khác: 1234import &#123; bet, start &#125; from './races_service';// chúng ta có thể dùngbet(race, pony1);start(race); Ngoài ra chúng ta có thể import tất cả các thành phần export bằng lệnh 1234import * as racesService from './races_service';// chúng ta có thể dùngracesService.bet(race, pony1);racesService.start(race); Nếu module chỉ export một function, class thì chúng ta có thể sử dụng keyword default như sau 12345// pony.jsexport default class Pony &#123;&#125;// races_service.jsimport Pony from './pony'; Chú ý khi import với keyword default chúng ta không cần dấu ngoặc đơn nữa. Chú ý một module chỉ cho phép một default keyword. Kết luậnĐây chỉ là tóm tắt những điểm cơ bản. ES6 còn rất nhiều điểm thú vị bên trong. Bạn có thể đọc thêm ở một số link sau: Understanding ECMAScript 6 exploringjs","categories":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hieunh161.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://hieunh161.github.io/tags/es6/"}]},{"title":"Những điểm mới trong ES6 (Phần 1)","slug":"javascript-es6","date":"2016-10-22T03:29:38.000Z","updated":"2016-10-22T06:58:33.121Z","comments":true,"path":"2016/10/22/javascript-es6/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/22/javascript-es6/","excerpt":"TranspilersNếu bạn là tín đồ của javascript chắc hẳn bạn phải biết tới đặc tả tiêu chuẩn của javascript là ECMAScript. Hiện nay các phiên bản javascript chúng ta sử dụng hầu hết được viết dựa trên ECMAScript version 5. Version 6 của ECMAScript đã ra đời với rất nhiều tính năng đáng chú ý, tuy nhiên chưa có nhiều trình duyệt hỗ trợ hoàn toàn phiên bản mới này. (Edge của Microsoft là một trong số ít các trình duyệt đi đầu hỗ trợ ES6). Để giải quyết vấn đề này cộng đồng đã cho ra đời một phương pháp giải quyết đó là transpiler.","keywords":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"text":"TranspilersNếu bạn là tín đồ của javascript chắc hẳn bạn phải biết tới đặc tả tiêu chuẩn của javascript là ECMAScript. Hiện nay các phiên bản javascript chúng ta sử dụng hầu hết được viết dựa trên ECMAScript version 5. Version 6 của ECMAScript đã ra đời với rất nhiều tính năng đáng chú ý, tuy nhiên chưa có nhiều trình duyệt hỗ trợ hoàn toàn phiên bản mới này. (Edge của Microsoft là một trong số ít các trình duyệt đi đầu hỗ trợ ES6). Để giải quyết vấn đề này cộng đồng đã cho ra đời một phương pháp giải quyết đó là transpiler.Transpiler = Source to source compiler là công cụ cho phép sử dụng ES6 source biên dịch sang ES5 và chạy nó trên các trình duyệt. Hiện tại có 2 project liên quan tới transpiler đáng chú ý đó là: Traceur Project của google Babeljs Một project được viết bởi Sebastian McKenzie (17 tuổi tại thời điểm viết babel), với rất nhiều sự đóng góp từ cộng đồng. Do đó việc đầu tiên nếu chúng ta muốn bắt đầu một dự án dùng ES6 mà chạy trên các trình duyệt cũ hơn thì chúng ta cần quan tâm tới các công cụ transpiler này. LetBiến var trong javascript khá rắc rối bởi vì javascript có một khái niệm gọi là hoisting. Nghĩa là biến thực tế sẽ được khai báo ở đàu hàm ngay cả khi chúng ta khai báo nó ở phía sau.Ví dụ chúng ta khái báo biến name trong if block: 1234567function getPonyFullName(pony) &#123; if (pony.isChampion) &#123; var name = 'Champion ' + pony.name; return name; &#125; return pony.name;&#125; nó sẽ không khác gì đoạn code dưới: 123456789function getPonyFullName(pony) &#123; var name; if (pony.isChampion) &#123; name = 'Champion ' + pony.name; return name; &#125; // name có thể được truy cập ở đây return pony.name;&#125; ES6 cung cấp một biến mà cho phép chúng ta khai báo đúng theo cách mà chúng ta muốn đó là let 12345678function getPonyFullName(pony) &#123; if (pony.isChampion) &#123; let name = 'Champion ' + pony.name; return name; &#125; // name bây giờ không thể được truy cập từ bên ngoài return pony.name;&#125; Biến name bây giờ sẽ được giới hạn trong block của nó. Let được giới thiệu để thay thế var, vì thế trong hầu hết trường hợp chúng ta đều sử dụng được let. Nếu bạn không thể sử dụng let mà phải sử dụng var thì đó là một dấu hiệu cho thấy code bạn đang có vấn đề. ConstantsES6 giới thiệu từ khóa const cho việc khai báo hằng số. Một khi chúng ta khai báo hằng số cho một đối tượng, chúng ta không thể gán lại giá trị cho nó sau này. 1234const poniesInRace = 6;// later in somewhereponiesInRace = 7; // SyntaxError Một điều vô cùng đặc biệt liên quan tới const đó là khi khai báo một object là const thì mặc dù chúng ta không thể gán nó cho đối tượng khác, nhưng chúng ta vẫn có thể thay đổi giá trị nội dung của nó.Ví dụ đoạn code sau sẽ lỗi: 12const PONY = &#123;&#125;;PONY = &#123;color: 'blue'&#125;; // SyntaxError Nhưng đoạn code sau sẽ chạy: 12const PONY = &#123;&#125;;PONY.color = 'blue'; // works Tương tự với array và các cấu trúc khác 12const PONIES = [];PONIES.push(&#123; color: 'blue' &#125;); // works Tạo ObjectViệc tạo đối tượng trong ES6 sẽ đơn giản hơn so với ES5 khi đối tượng chúng ta muốn tạo có tên trùng với tên biến chúng ta muốn gán.Ví dụ: 12345function createPony() &#123; const name = 'Rainbow Dash'; const color = 'blue'; return &#123; name: name, color: color &#125;;&#125; Đoạn code trên có thể đơn giản trở thành: 12345function createPony() &#123; const name = 'Rainbow Dash'; const color = 'blue'; return &#123; name, color &#125;;&#125; Destructuring assignmentTrong ES5: 1234var httpOptions = &#123; timeout: 2000, isCache: true &#125;;// latervar httpTimeout = httpOptions.timeout;var httpCache = httpOptions.isCache; Trong ES6 chúng ta có thể đơn giản: 123const httpOptions = &#123; timeout: 2000, isCache: true &#125;;// laterconst &#123; timeout: httpTimeout, isCache: httpCache &#125; = httpOptions; Nếu tên biến và tên của đối tượng trùng nhau nó có thể còn trở nên đơn giản hơn nữa: 1234const httpOptions = &#123; timeout: 2000, isCache: true &#125;;// laterconst &#123; timeout, isCache &#125; = httpOptions;// Chúng ta có 2 biến timeout và isCache với giá trị từ httpOptions Tương tự với mảng chúng ta có 1234const timeouts = [1000, 2000, 3000];// laterconst [shortTimeout, mediumTimeout] = timeouts;// chúng ta có biến 'shortTimeout' = 1000 và 'mediumTimeout' = 2000 Từ trên chúng ta có thêm một tính năng rất thú vị của ES6 đó là kết quả trả về có thể là nhiều giá trị. 1234567function randomPonyInRace() &#123; const pony = &#123; name: 'Rainbow Dash' &#125;; const position = 2; // ... return &#123; pony, position &#125;;&#125;const &#123; position, pony &#125; = randomPonyInRace(); Trong trường hợp chúng ta chỉ muốn lấy một giá trị chúng ta sử dụng Destructuring để lấy: 1234567function randomPonyInRace() &#123; const pony = &#123; name: 'Rainbow Dash' &#125;; const position = 2; // ... return &#123; pony, position &#125;;&#125;const &#123; pony &#125; = randomPonyInRace(); Kết quả chúng ta sẽ chỉ lấy giá trị pony Các giá trị và tham số mặc địnhMột trong những đặc điểm nổi bật của javascript là cho phép người dùng gọi hàm với số lượng tham số bất kỳ Nếu chúng ta truyền nhiều hơn số lượng tham số khai báo, phần vượt quá sẽ được bỏ qua. Chính sác hơn chúng ta có thể lấy phần tham số thừa thông qua biến đặc biệt là arguments Nếu chúng ta truyền ít hơn tham số khai báo, phần thiếu sẽ có giá trị là undefinedTrong trường hợp thứ 2 thông thường khi muốn thêm mặc định cho biến chúng ta thường làm như sau 123456function getPonies(size, page) &#123; size = size || 10; page = page || 1; // ... server.get(size, page);&#125; ES6 cung cấp cho chúng ta cách làm đơn giản hơn trong trường hợp này 1234function getPonies(size = 10, page = 1) &#123; // ... server.get(size, page);&#125; Có một chút khác biệt nhỏ giữa 2 cách. Vì 0 và “” là các giá trị hợp lệ, do đó nó sẽ không được thay thế bởi giá trị mặc định. Trong khi size = size || 10 sẽ lấy giá trị 10 khi truyền size = 0. Trong ES6 cách tính sẽ giống như dùng công thức sau size = size === undefined ? 10: size; Giá trị mặc định có thể là hàm hoặc có thể là biến khác 1234function getPonies(size = defaultSize(), page = size - 1) &#123; // ... server.get(size, page);&#125; Chúng ta có thể sử dụng giá trị mặc định cho các việc Destructuring biến như sau: 1234const &#123; timeout = 1000 &#125; = httpOptions;// you now have a variable named 'timeout',// with the value of 'httpOptions.timeout' if it exists// or 1000 if not Toán tử Rest …Vói javascript chúng ta có thể làm như sau khi truyền nhiều tham số hơn số lượng khai báo. 123456function addPonies(ponies) &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; poniesInRace.push(arguments[i]); &#125;&#125;addPonies('Rainbow Dash', 'Pinkie Pie'); ES6 giới thiệu một cú pháp mới để định nghĩa các biến tham số trong các hàm một cách ngắn gọn hơn đó là toán tử Rest … 12345function addPonies(...ponies) &#123; for (let pony of ponies) &#123; poniesInRace.push(pony); &#125;&#125; ponies giờ sẽ trở thành một mảng có thể loop được bằng cách sử dụng for … of. (Đây cũng là một tính năng mới của ES6). Toán tử Rest được sử dụng để lấy list các tham số truyền vào hàm.Toán tử rest cũng có thể áp dụng khi Destructuring dữ liệu 1234const [winner, ...losers] = poniesInRace;// poniesInRace là một mảng chứa nhiều pony// 'winner' sẽ chứa pony đầu tiên// và 'losers' sẽ là một mảng của các phần tử còn lại Toán tử Spread …Trong khi Rest sử dụng để cấu thành nhiều biến riêng biệt thành một mảng đơn lẻ, thì spread lại mang ý nghĩa ngược lại là phân tách 1 mảng thành các phần tử riêng lẻ. 12const ponyPrices = [12, 3, 4];const minPrice = Math.min(...ponyPrices); Tobe continued …","categories":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hieunh161.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://hieunh161.github.io/tags/es6/"}]},{"title":"Hướng dẫn viết blog","slug":"guideline-hexo","date":"2016-10-20T15:20:04.000Z","updated":"2016-10-22T09:04:38.644Z","comments":true,"path":"2016/10/21/guideline-hexo/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/21/guideline-hexo/","excerpt":"Cài đặt môi trườngBlog sử dụng hexo dựa trên nodejs nên cần cài đặt nodejs cài đặt nodejs cài đặt hexo 1npm install hexo-cli -g","keywords":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/categories/guideline/"}],"text":"Cài đặt môi trườngBlog sử dụng hexo dựa trên nodejs nên cần cài đặt nodejs cài đặt nodejs cài đặt hexo 1npm install hexo-cli -g Get source code từ github clone blog source về máy từ github và cài đặt dependencies 123git clone https://github.com/hieunh161/at-blog.gitcd &#123;thư mục source&#125;npm install Tạo bài viết mới và public lên heroku Tạo bài viết mới bằng lệnh 12cd &#123;thư mục source&#125;hexo new post &#123;tên bài viết&#125; Vào thư mục source/_posts viết bài bằng markdown.Có thể tham khảo markdown cheatsheet ở đây Commit source lên git sau đó deploy source lên server 1npm run deploy","categories":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/categories/guideline/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/tags/guideline/"}]},{"title":"Hospitality","slug":"hospitality","date":"2016-10-20T14:20:04.000Z","updated":"2016-10-22T07:26:21.000Z","comments":true,"path":"2016/10/20/hospitality/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/20/hospitality/","excerpt":"1. Hospitality là gì?Hospitality là một từ xuất hiện ở Anh từ khoảng năm 1325 – 1375. Theo từ điển thì nó có nghĩa là việc đối xử một cách thân thiện, tử tế của một người chủ với một người khách hoặc một người lạ nào đó. Ví dụ như câu give a person a hospitality. Nó là một danh từ đếm được, nghĩa là có thể có nhiều hospitalities, tức là có nhiều hành động tử tế. Khi nó du nhập vào Nhật thì người Nhật chấp nhận từ đó với ý nghĩa là nghĩ cho người khác, làm những điều vì người khác, hay đối xử với người khác từ trái tim mình đúng như văn hóa của người Nhật. Và đặc biệt từ này đã trở thành một từ như chỉ về các dịch vụ đặc biệt làm hài lòng khách hàng trong kinh doanh. Khi nói về việc làm một hospitality cho một người nào khác thì người Nhật hiểu rằng hành động đó không chỉ là vì đối phương mà nó còn hàm chứa cả tấm lòng của người thực hiện hành động.","keywords":[{"name":"social","slug":"social","permalink":"https://hieunh161.github.io/categories/social/"}],"text":"1. Hospitality là gì?Hospitality là một từ xuất hiện ở Anh từ khoảng năm 1325 – 1375. Theo từ điển thì nó có nghĩa là việc đối xử một cách thân thiện, tử tế của một người chủ với một người khách hoặc một người lạ nào đó. Ví dụ như câu give a person a hospitality. Nó là một danh từ đếm được, nghĩa là có thể có nhiều hospitalities, tức là có nhiều hành động tử tế. Khi nó du nhập vào Nhật thì người Nhật chấp nhận từ đó với ý nghĩa là nghĩ cho người khác, làm những điều vì người khác, hay đối xử với người khác từ trái tim mình đúng như văn hóa của người Nhật. Và đặc biệt từ này đã trở thành một từ như chỉ về các dịch vụ đặc biệt làm hài lòng khách hàng trong kinh doanh. Khi nói về việc làm một hospitality cho một người nào khác thì người Nhật hiểu rằng hành động đó không chỉ là vì đối phương mà nó còn hàm chứa cả tấm lòng của người thực hiện hành động. 2. Hospitality và dịch vụ (services)Trong kinh doanh người ta hay thường nói rằng chúng ta kinh doanh dịch vụ (services) và các công ty luôn cố gắng rằng mình sẽ phải đưa ra các dịch vụ tốt nhất theo ý hiểu đó là làm hài lòng khách hàng. Và hầu như trong thời đại ngày nay nó như là một điều tất yếu. Ở Việt Nam dù cách hành xử vẫn chưa được tốt, nhưng ko thể phủ nhận xu thế này cũng đang dần dần trở thành một điều tất yếu khi nền kinh tế hội nhập và vận động theo cơ chế thị trường. Khi việc cạnh tranh giữa các công ty ngày một khốc liệt hơn, họ không chỉ cạnh tranh về giá, về chất lượng sản phẩm mà còn về chất lượng dịch vụ cung cấp. Như là lắp đặt tận nơi, giúp đỡ vận chuyển tận nhà …Vậy thì sự khác biệt giữa dịch vụ và hospitality nghĩa là gì? Để làm rõ sự khác biệt chúng ta bắt đầu từ nguồn gốc xuất xứ. Từ service xuất phát từ các từ gốc latin là servus , slane, servant nghĩa là nô lệ hay đầy tớ. Người nhận service chính là người chủ, theo nghĩa quan hệ chủ tớ. Và nó cho thấy việc thể hiện thái độ tôn trọng khách hàng, khách hàng là thượng đế đúng quan điểm của người phương tây. Với từ hospitality thì nó xuất phát từ hospital, hospics, hospice nghĩa là bệnh viện, trại chăm sóc, người chăm sóc. … Từ đó điểm khác biệt lớn nhất của 2 từ nằm ở việc từ hospitality mang khuynh hướng của sự đối xử, chăm sóc, niềm vui khi được làm việc gì đó cho người khác hơn là việc làm vì trách nhiệm. Bạn nên hiểu rằng khi mà ngày xưa việc chăm sóc y tế không phải là dịch vụ như bây giờ, nó còn bao gồm cả tình cảm giữa con người với con người, sự giúp đỡ nhau lúc khó khăn … 3. Các bước cơ bảnVậy chúng ta phải hiểu hospitality là như thế nào. Liệu có mối dung hòa nào giữa hospitality và service không. Để cho dễ hình dung chúng ta sẽ xem hospitality như là 3 giai đoạn của dịch vụ như sau. Giai đoạn 1 của dịch vụĐó là việc người cung cấp dịch vụ phải cung cấp cho người dùng dịch vụ những việc hiển nhiên được yêu cầu trong hợp đồng cung cấp. Ví dụ như chúng ta là những là gia sư khi chúng ta đi dậy thì đương nhiên nghĩa vụ và trách nhiệm của chúng ta là phải dạy cho học sinh kiến thức đầy đủ, phù hợp. Ở đây đó là đương nhiên, đúng theo quy luật cung cầu, vì bố mẹ học sinh đã trả tiền để chúng ta làm việc đấy. Hay như chúng ta vào cửa hàng và mua một chiếc áo, thì khi chúng ta trả giá đầy đủ như đã thỏa thuận, hiển nhiên chúng ta sẽ được sở hữu chiếc áo đó. Giai đoạn 2 của dịch vụĐây là giai đoạn mà mục đích là làm cho khách hàng hài lòng hơn nữa, ở giai đoạn này, ngoài dịch vụ đương nhiên, người cung cấp dịch vụ còn làm thế nào đó để cho khách hàng cảm thấy thoải mái, vui vẻ và mong muốn gắn bó lâu dài với dịch vụ của mình hơn bằng việc tạo ra các ấn tượng tốt, chu đáo và kết quả là làm hài lòng khách hàng. Ví dụ như khi chúng ta vào mua quần áo, thì chúng ta sẽ luôn thấy nụ cười trên môi người bán hàng, luôn thấy họ đon đả, cho phép chúng ta lựa chọn thoải mái, giúp đỡ chúng ta tư vấn các sản phẩm phù hợp … Hầu hết hiện nay có lẽ không có cửa hàng nào ko ý thức được điều này. Nó như là một điều hiển nhiên ở các cty có chất lượng dịch vụ tốt hiện nay. Giai đoạn 3 của dịch vụVới 2 giai đoạn trên, có thể chúng ta đã có một dịch vụ tốt, một lượng khách hàng tiềm năng và một khoản khách thường xuyên kha khá. Vì chúng ta luôn làm khách hàng hài lòng, làm họ cảm thấy họ là thượng đế. Vậy thì giai đoạn 3 này là gì nữa, và đây chính là giai đoạn để một service trở thành một hospitality. Ở giai đoạn này không những làm khách hàng cảm thấy hài lòng về dịch vụ, người cung cấp dịch vụ còn phải suy nghĩ nghiêm túc về sở thích, những điều khách hàng thích, và những điều khách hàng mong muốn. Từ đó cung cấp cho khách hàng những điều vượt quá sự mong đợi của họ. Với người Nhật họ thường hay nói đó chính là việc xem những khách hàng như những người thân, dành tình cảm để làm cho họ như tình cảm với gia đình mình, cung cấp cho họ dịch vụ như họ là cha mẹ, anh em, bạn bè của mình. Từ đó để có thể hiểu thấu khách hàng, đưa cho họ một dịch vụ tuyệt vời nhất họ có được. Ví dụ như với mỗi người khách vào mua áo, người bán hàng không những tư vấn để mua hàng của mình, mà phải tư vấn làm sao để khách hàng mua được sản phẩm tốt nhất, hợp lý nhất, ưng ý nhất. Như thể mình bán cho người thân của mình, thì đó chính là điều mà hospitality nói đến.Nói đến 3 giai đoạn này bạn có thể hiểu một câu chuyện vui nhưng rất thật về tính cách 3 con người, Việt Nam, Pháp và Nhật. Câu chuyện nói rằng, khi người Việt Nam buồn, họ sẽ vác bộ mặt đó lên công ty và đối xử với khách hàng với bộ mặt đó, như thể khách hàng là nơi xả nỗi bực tức của họ. Người Pháp thì dù vui hay buồn, họ lúc nào cũng tươi cười với khách hàng. Với người Nhật khi khách hàng buồn, dù họ có đang vui họ cũng sẽ buồn cùng với khách hàng, khi khách hàng vui họ sẽ vui cùng với khách hàng. Đó chỉ là một câu chuyện nhưng thực tế chính là tính cách của 3 con người ở 3 nơi. Việt Nam, Nhật, phương Tây. Hơn thế nữa nó áp dụng rất chính xác vào 3 giai đoạn của một dịch vụ. Người Việt Nam ở giai đoạn 1, phương tây ở giai đoạn 2 và người Nhật ở giai đoạn 3. Nếu bạn đọc báo nhiều về đức tính của người Nhật hoặc đất nước Nhật bạn sẽ hiểu tại sao Nhật được xem là đất nước có dịch vụ tốt nhất thế giới.Các công ty trên thế giới đang chạy đua với nhau không chỉ về chiến lược, sản phẩm … mà quan trọng hơn hết là về chất lượng dịch vụ. Apple sẽ không thể thành công nếu chất lượng dịch vụ khôn tốt. Điều đó là rõ ràng và hiển nhiên.","categories":[{"name":"social","slug":"social","permalink":"https://hieunh161.github.io/categories/social/"}],"tags":[{"name":"soft-skill","slug":"soft-skill","permalink":"https://hieunh161.github.io/tags/soft-skill/"}]}]}