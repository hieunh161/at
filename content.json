{"meta":{"title":"AT Team","subtitle":null,"description":null,"author":"AT Team","url":"https://hieunh161.github.io"},"pages":[{"title":"about","date":"2016-10-20T14:44:15.000Z","updated":"2016-10-22T07:41:46.412Z","comments":true,"path":"about/index.html","permalink":"https://hieunh161.github.io/about/index.html","excerpt":"","text":"Team AT = Advance Technology TeamĐây là hình ảnh của team chúng tôi."}],"posts":[{"title":"Những điểm mới trong ES6 (Phần 2)","slug":"javascript-es6-2","date":"2016-10-22T09:55:40.000Z","updated":"2016-10-23T05:30:18.000Z","comments":true,"path":"2016/10/22/javascript-es6-2/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/22/javascript-es6-2/","excerpt":"ClassMột trong những tính năng được mong chờ nhất trong javascript chính là class. Mặc dù trên ES5 chúng ta có thể tạo được class, tuy nhiên đó là một cách không dễ dàng đối với những người mới bắt đầu code javascript. Với ES6 mọi thứ trở nên rất dễ dàng: 1234567891011class Pony &#123; constructor(color) &#123; this.color = color; &#125; toString() &#123; return `$&#123;this.color&#125; pony`; // 'template literals' là một tính năng rất hay khác nữa trong ES6 &#125;&#125;const bluePony = new Pony('blue');console.log(bluePony.toString()); // blue pony","keywords":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"text":"ClassMột trong những tính năng được mong chờ nhất trong javascript chính là class. Mặc dù trên ES5 chúng ta có thể tạo được class, tuy nhiên đó là một cách không dễ dàng đối với những người mới bắt đầu code javascript. Với ES6 mọi thứ trở nên rất dễ dàng: 1234567891011class Pony &#123; constructor(color) &#123; this.color = color; &#125; toString() &#123; return `$&#123;this.color&#125; pony`; // 'template literals' là một tính năng rất hay khác nữa trong ES6 &#125;&#125;const bluePony = new Pony('blue');console.log(bluePony.toString()); // blue pony class trong javascript không giống biến var, khi chúng ta bắt buộc phải khai báo nó trước khi sử dụng. Bạn sẽ nhận ra hàm rất đặc biệt là constructor. Hàm này sẽ được gọi khi chúng ta dùng toán tử new để khởi tạo đối tượng.Tương tự như các ngôn ngữ khác, ES6 cho phép khai báo static bên trong class. Với hàm hoặc thuộc tính được khai báo static, chúng ta có thể truy cập trực tiếp mà không cần khởi tạo đối tượng. 123456class Pony &#123; static defaultSpeed() &#123; return 10; &#125;&#125;const speed = Pony.defaultSpeed(); Nếu bạn là tín đồ của hướng đối tượng, chắc chắn bạn sẽ mong muốn các tính năng khác như set, get, kế thừa … ES6 cung cấp đầy đủ điều đó. Khi chúng ta muốn get/set: 12345678910111213141516class Pony &#123; get color() &#123; console.log('get color'); return this._color; &#125; set color(newColor) &#123; console.log(`set color $&#123;newColor&#125;`); this._color = newColor; &#125;&#125;const pony = new Pony();pony.color = 'red';// 'set color red'console.log(pony.color);// 'get color'// 'red' Kế thừa trong ES6 như sau: 123456789class Animal &#123; speed() &#123; return 10; &#125;&#125;class Pony extends Animal &#123;&#125;const pony = new Pony();console.log(pony.speed()); // 10, as Pony kế thừa method lớp cha Bạn có thể override method cha như bất kỳ ngôn ngữ hướng đối tượng thông thường nào khác. 123456789101112class Animal &#123; speed() &#123; return 10; &#125;&#125;class Pony extends Animal &#123; speed() &#123; return super.speed() + 10; &#125;&#125;const pony = new Pony();console.log(pony.speed()); // 20, as Pony overrides the parent method Javascript có vẻ đã trở nên rất giống Java khi chúng ta cũng có thể sử dụng từ khóa super để gọi các hàm của lớp cha. PromisesPromise không phải tính năng quá mới mẻ, nó đã có trong Angular1 và nếu bạn đã từng code Angular2 thì chắc không quá xa lạ với khái niệm này.Mục đích của Promise là làm đơn giản việc lập trình không đồng bộ (Asynchronous). Chúng ta thường sử dụng callback để xử lý kết quả trả về trong ES5 khi muốn thực hiện sử lý không đồng bộ như AJAX. Promise giúp chúng ta làm phẳng code, dễ dàng trong việc đọc và bảo trì code hơn. Hãy xem ví dụ sau khi thực hiện với callback và với Promise. Với callback: 12345getUser(login, function (user) &#123; getRights(user, function (rights) &#123; updateMenu(rights); &#125;);&#125;); Với Promise: 1234567getUser(login) .then(function (user) &#123; return getRights(user); &#125;) .then(function (rights) &#123; updateMenu(rights); &#125;) Mặc định Promise có thể hiểu là một đối tượng thenable nghĩa là nó có hàm then . Hàm này sẽ nhận hai tham số, một xử lý khi thành công và một cho thất bại. Promise có 3 thành phần sau: pending: Khi promise chưa hoàn thành fulfilled: Khi promise thực hiện thành công rejected: Khi promise thực hiện thất bại Khi promise được fulfilled thì hàm success sẽ được gọi, và ngược lại khi rejected thì hàm xử lý lỗi sẽ được gọi.Vậy làm thế nào để gọi Promise? Chúng ta chỉ đơn giản khởi tạo một đối tượng có tên Promise. Hàm này sẽ nhận 2 tham số callback như đã nói ở trên, một cho thành công, một cho thất bại. 12345678910const getUser = function (login) &#123; return new Promise(function (resolve, reject) &#123; // async stuff, like fetching users from server, returning a response if (response.status === 200) &#123; resolve(response.data); &#125; else &#123; reject('No user'); &#125; &#125;);&#125;; Khi khai báo như trên xong chúng ta có thể sử dụng getUser với hàm then. Trong trường hợp chỉ muốn xử lý thành công chúng ta có thể bỏ qua biến reject như dưới. 1234getUser(login) .then(function (user) &#123; console.log(user); &#125;) Điểm hay của Promise như đã nói ở trên đó là nó làm phẳng code của chúng ta. Trong trường hợp chúng ta có nhiều callback lồng nhau thông thường chúng ta có thể viết: 1234567getUser(login) .then(function (user) &#123; return getRights(user) // getRights is returning a promise .then(function (rights) &#123; return updateMenu(rights); &#125;); &#125;) Nhưng với promise chúng ta có thể viết một cách đẹp đẽ hơn thế. 1234567getUser(login) .then(function (user) &#123; return getRights(user) // getRights is returning a promise &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;); Một điểm thú vị nữa đó là hàm xử lý lỗi, chúng ta có thể viết riêng cho từng promise, nhưng cũng có thể gộp chung cho một chuỗi promise như sau:Xử lý lỗi cho từng promise 12345678910111213getUser(login) .then(function (user) &#123; return getRights(user); &#125;, function (error) &#123; console.log(error); // xử lý cho getUser failed return Promise.reject(error); &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;, function (error) &#123; console.log(error); // xử lý cho getRights failed return Promise.reject(error); &#125;) Xử lý lỗi chung có các promise với catch 12345678910getUser(login) .then(function (user) &#123; return getRights(user); &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;) .catch(function (error) &#123; console.log(error); // Xử lý lỗi chung khi có một xử lý trong chuỗi lỗi &#125;) Arrow functionsĐây là một trong những tính năng cá nhân mình thích nhất của ES6. Sử dụng hàm mũi tên sẽ vô cùng tiện dụng trong nhiều trường hợp. Quay trở lại với ví dụ về Promise phía trên ta có: 1234567getUser(login) .then(function (user) &#123; return getRights(user); // getRights is returning a promise &#125;) .then(function (rights) &#123; return updateMenu(rights); &#125;) Khi sử dụng cú pháp arrow chúng ta có thể viết lại như sau: 123getUser(login) .then(user =&gt; return getRights(user))// getRights is returning a promise .then(rights =&gt; return updateMenu(rights)) Rất đẹp phải không nào.Tôi đã không nói nên lời khi lần đầu tiên sử dụng cú pháp này trong dự án của mình. Bởi vì nó làm cho code trở nên vô cùng đẹp. Chúng ta phải chú ý là khi giá trị trả về là một block code chúng ta cần có ngoặc đơn như sau: 123456getUser(login) .then(user =&gt; &#123; console.log(user); return getRights(user); &#125;) .then(rights =&gt; updateMenu(rights)) Cú pháp arrow không chỉ giúp cho việc code trở nên đơn giản hơn mà nó còn có một đặc điểm rất quan trọng sau.Lấy ví dụ đoạn code sau: 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Đoạn code trên sẽ không chạy như bạn mong đợi. Bởi vì this trong javascript sẽ trỏ tới đối tượng đang được tương tác.Tuy nhiên trong trường hợp này khi sử dụng hàm anonymous trong hàm forEach thì biến this sẽ được trỏ tới Window. Tất nhiên chúng ta có thể fix vấn đề này một cách đơn giản bằng việc gán lại biến this cho một biến khác để đảm bảo trỏ đúng tới đối tượng mong muôn: 1234567891011121314151617var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate var self = this; numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; self.max) &#123; self.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Hoặc có thể sử dụng hàm bind để gắn con trỏ this vào. 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;.bind(this)); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Thậm chí có thể truyền trực tiếp biến this như một tham số thứ 2 cho hàm forEach 12345678910111213141516var maxFinder = &#123; max: 0, find: function (numbers) &#123; // let's iterate numbers.forEach( function (element) &#123; // if the element is greater, set it as the max if (element &gt; this.max) &#123; this.max = element; &#125; &#125;, this); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Với ES6 mọi thứ trở nên dễ dàng hơn với arrow function: 12345678910111213const maxFinder = &#123; max: 0, find: function (numbers) &#123; numbers.forEach(element =&gt; &#123; if (element &gt; this.max) &#123; this.max = element; &#125; &#125;); &#125;&#125;;maxFinder.find([2, 3, 4]);// log the resultconsole.log(maxFinder.max); Sets and MapsVới ES6 chúng ta có thêm các kiểu dữ liệu collection là Set và Map. Bạn nào từng làm Java sẽ thích điều này. Ví dụ về Map: 123456const cedric = &#123; id: 1, name: 'Cedric' &#125;;const users = new Map();users.set(cedric.id, cedric); // adds a userconsole.log(users.has(cedric.id)); // trueconsole.log(users.size); // 1users.delete(cedric.id); // removes the user Ví dụ về Set 123456const cedric = &#123; id: 1, name: 'Cedric' &#125;;const users = new Set();users.add(cedric); // adds a userconsole.log(users.has(cedric)); // trueconsole.log(users.size); // 1users.delete(cedric); // removes the user Cuối cùng như bao collection khác, chúng ta có thể loop thông qua for … of 123for (let user of users) &#123; console.log(user.name);&#125; Template literalsNối string luôn là một chuyện rườm rà trong javascript. Chúng ta thông thường sẽ làm: 1const fullname = 'Miss ' + firstname + ' ' + lastname; Nhưng với chức năng template literal thì mọi chuyện sẽ trở nên dễ dàng hơn nhiều 1const fullname = `Miss $&#123;firstname&#125; $&#123;lastname&#125;`; Và thậm chí nó còn trở nên hữu ích hơn rất nhiều khi nó hỗ trợ chức năng multi line. 123const template = `&lt;div&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;/div&gt;`; ModulesModule là một chức năng còn thiếu của javascript cho tới ES5. Khi chúng ta muốn tổ chức code, chúng ta đều phải sử dụng các third party như RequireJs.ES6 cung cấp thêm chức năng module và các cú pháp cho phép chúng ta import/export thông tin từ các modules. Mặc định mỗi file là một module riêng biệt trong ES6. File races_service.js123456export function bet(race, pony) &#123; // ...&#125;export function start(race) &#123; // ...&#125; Với từ khóa export chúng ta export 2 hàm, và ở một file khác: 1234import &#123; bet, start &#125; from './races_service';// chúng ta có thể dùngbet(race, pony1);start(race); Ngoài ra chúng ta có thể import tất cả các thành phần export bằng lệnh 1234import * as racesService from './races_service';// chúng ta có thể dùngracesService.bet(race, pony1);racesService.start(race); Nếu module chỉ export một function, class thì chúng ta có thể sử dụng keyword default như sau 12345// pony.jsexport default class Pony &#123;&#125;// races_service.jsimport Pony from './pony'; Chú ý khi import với keyword default chúng ta không cần dấu ngoặc đơn nữa. Chú ý một module chỉ cho phép một default keyword. Kết luậnĐây chỉ là tóm tắt những điểm cơ bản. ES6 còn rất nhiều điểm thú vị bên trong. Bạn có thể đọc thêm ở một số link sau: Understanding ECMAScript 6 exploringjs","categories":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hieunh161.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://hieunh161.github.io/tags/es6/"}]},{"title":"Những điểm mới trong ES6 (Phần 1)","slug":"javascript-es6","date":"2016-10-22T03:29:38.000Z","updated":"2016-10-22T06:58:33.121Z","comments":true,"path":"2016/10/22/javascript-es6/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/22/javascript-es6/","excerpt":"TranspilersNếu bạn là tín đồ của javascript chắc hẳn bạn phải biết tới đặc tả tiêu chuẩn của javascript là ECMAScript. Hiện nay các phiên bản javascript chúng ta sử dụng hầu hết được viết dựa trên ECMAScript version 5. Version 6 của ECMAScript đã ra đời với rất nhiều tính năng đáng chú ý, tuy nhiên chưa có nhiều trình duyệt hỗ trợ hoàn toàn phiên bản mới này. (Edge của Microsoft là một trong số ít các trình duyệt đi đầu hỗ trợ ES6). Để giải quyết vấn đề này cộng đồng đã cho ra đời một phương pháp giải quyết đó là transpiler.","keywords":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"text":"TranspilersNếu bạn là tín đồ của javascript chắc hẳn bạn phải biết tới đặc tả tiêu chuẩn của javascript là ECMAScript. Hiện nay các phiên bản javascript chúng ta sử dụng hầu hết được viết dựa trên ECMAScript version 5. Version 6 của ECMAScript đã ra đời với rất nhiều tính năng đáng chú ý, tuy nhiên chưa có nhiều trình duyệt hỗ trợ hoàn toàn phiên bản mới này. (Edge của Microsoft là một trong số ít các trình duyệt đi đầu hỗ trợ ES6). Để giải quyết vấn đề này cộng đồng đã cho ra đời một phương pháp giải quyết đó là transpiler.Transpiler = Source to source compiler là công cụ cho phép sử dụng ES6 source biên dịch sang ES5 và chạy nó trên các trình duyệt. Hiện tại có 2 project liên quan tới transpiler đáng chú ý đó là: Traceur Project của google Babeljs Một project được viết bởi Sebastian McKenzie (17 tuổi tại thời điểm viết babel), với rất nhiều sự đóng góp từ cộng đồng. Do đó việc đầu tiên nếu chúng ta muốn bắt đầu một dự án dùng ES6 mà chạy trên các trình duyệt cũ hơn thì chúng ta cần quan tâm tới các công cụ transpiler này. LetBiến var trong javascript khá rắc rối bởi vì javascript có một khái niệm gọi là hoisting. Nghĩa là biến thực tế sẽ được khai báo ở đàu hàm ngay cả khi chúng ta khai báo nó ở phía sau.Ví dụ chúng ta khái báo biến name trong if block: 1234567function getPonyFullName(pony) &#123; if (pony.isChampion) &#123; var name = 'Champion ' + pony.name; return name; &#125; return pony.name;&#125; nó sẽ không khác gì đoạn code dưới: 123456789function getPonyFullName(pony) &#123; var name; if (pony.isChampion) &#123; name = 'Champion ' + pony.name; return name; &#125; // name có thể được truy cập ở đây return pony.name;&#125; ES6 cung cấp một biến mà cho phép chúng ta khai báo đúng theo cách mà chúng ta muốn đó là let 12345678function getPonyFullName(pony) &#123; if (pony.isChampion) &#123; let name = 'Champion ' + pony.name; return name; &#125; // name bây giờ không thể được truy cập từ bên ngoài return pony.name;&#125; Biến name bây giờ sẽ được giới hạn trong block của nó. Let được giới thiệu để thay thế var, vì thế trong hầu hết trường hợp chúng ta đều sử dụng được let. Nếu bạn không thể sử dụng let mà phải sử dụng var thì đó là một dấu hiệu cho thấy code bạn đang có vấn đề. ConstantsES6 giới thiệu từ khóa const cho việc khai báo hằng số. Một khi chúng ta khai báo hằng số cho một đối tượng, chúng ta không thể gán lại giá trị cho nó sau này. 1234const poniesInRace = 6;// later in somewhereponiesInRace = 7; // SyntaxError Một điều vô cùng đặc biệt liên quan tới const đó là khi khai báo một object là const thì mặc dù chúng ta không thể gán nó cho đối tượng khác, nhưng chúng ta vẫn có thể thay đổi giá trị nội dung của nó.Ví dụ đoạn code sau sẽ lỗi: 12const PONY = &#123;&#125;;PONY = &#123;color: 'blue'&#125;; // SyntaxError Nhưng đoạn code sau sẽ chạy: 12const PONY = &#123;&#125;;PONY.color = 'blue'; // works Tương tự với array và các cấu trúc khác 12const PONIES = [];PONIES.push(&#123; color: 'blue' &#125;); // works Tạo ObjectViệc tạo đối tượng trong ES6 sẽ đơn giản hơn so với ES5 khi đối tượng chúng ta muốn tạo có tên trùng với tên biến chúng ta muốn gán.Ví dụ: 12345function createPony() &#123; const name = 'Rainbow Dash'; const color = 'blue'; return &#123; name: name, color: color &#125;;&#125; Đoạn code trên có thể đơn giản trở thành: 12345function createPony() &#123; const name = 'Rainbow Dash'; const color = 'blue'; return &#123; name, color &#125;;&#125; Destructuring assignmentTrong ES5: 1234var httpOptions = &#123; timeout: 2000, isCache: true &#125;;// latervar httpTimeout = httpOptions.timeout;var httpCache = httpOptions.isCache; Trong ES6 chúng ta có thể đơn giản: 123const httpOptions = &#123; timeout: 2000, isCache: true &#125;;// laterconst &#123; timeout: httpTimeout, isCache: httpCache &#125; = httpOptions; Nếu tên biến và tên của đối tượng trùng nhau nó có thể còn trở nên đơn giản hơn nữa: 1234const httpOptions = &#123; timeout: 2000, isCache: true &#125;;// laterconst &#123; timeout, isCache &#125; = httpOptions;// Chúng ta có 2 biến timeout và isCache với giá trị từ httpOptions Tương tự với mảng chúng ta có 1234const timeouts = [1000, 2000, 3000];// laterconst [shortTimeout, mediumTimeout] = timeouts;// chúng ta có biến 'shortTimeout' = 1000 và 'mediumTimeout' = 2000 Từ trên chúng ta có thêm một tính năng rất thú vị của ES6 đó là kết quả trả về có thể là nhiều giá trị. 1234567function randomPonyInRace() &#123; const pony = &#123; name: 'Rainbow Dash' &#125;; const position = 2; // ... return &#123; pony, position &#125;;&#125;const &#123; position, pony &#125; = randomPonyInRace(); Trong trường hợp chúng ta chỉ muốn lấy một giá trị chúng ta sử dụng Destructuring để lấy: 1234567function randomPonyInRace() &#123; const pony = &#123; name: 'Rainbow Dash' &#125;; const position = 2; // ... return &#123; pony, position &#125;;&#125;const &#123; pony &#125; = randomPonyInRace(); Kết quả chúng ta sẽ chỉ lấy giá trị pony Các giá trị và tham số mặc địnhMột trong những đặc điểm nổi bật của javascript là cho phép người dùng gọi hàm với số lượng tham số bất kỳ Nếu chúng ta truyền nhiều hơn số lượng tham số khai báo, phần vượt quá sẽ được bỏ qua. Chính sác hơn chúng ta có thể lấy phần tham số thừa thông qua biến đặc biệt là arguments Nếu chúng ta truyền ít hơn tham số khai báo, phần thiếu sẽ có giá trị là undefinedTrong trường hợp thứ 2 thông thường khi muốn thêm mặc định cho biến chúng ta thường làm như sau 123456function getPonies(size, page) &#123; size = size || 10; page = page || 1; // ... server.get(size, page);&#125; ES6 cung cấp cho chúng ta cách làm đơn giản hơn trong trường hợp này 1234function getPonies(size = 10, page = 1) &#123; // ... server.get(size, page);&#125; Có một chút khác biệt nhỏ giữa 2 cách. Vì 0 và “” là các giá trị hợp lệ, do đó nó sẽ không được thay thế bởi giá trị mặc định. Trong khi size = size || 10 sẽ lấy giá trị 10 khi truyền size = 0. Trong ES6 cách tính sẽ giống như dùng công thức sau size = size === undefined ? 10: size; Giá trị mặc định có thể là hàm hoặc có thể là biến khác 1234function getPonies(size = defaultSize(), page = size - 1) &#123; // ... server.get(size, page);&#125; Chúng ta có thể sử dụng giá trị mặc định cho các việc Destructuring biến như sau: 1234const &#123; timeout = 1000 &#125; = httpOptions;// you now have a variable named 'timeout',// with the value of 'httpOptions.timeout' if it exists// or 1000 if not Toán tử Rest …Vói javascript chúng ta có thể làm như sau khi truyền nhiều tham số hơn số lượng khai báo. 123456function addPonies(ponies) &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; poniesInRace.push(arguments[i]); &#125;&#125;addPonies('Rainbow Dash', 'Pinkie Pie'); ES6 giới thiệu một cú pháp mới để định nghĩa các biến tham số trong các hàm một cách ngắn gọn hơn đó là toán tử Rest … 12345function addPonies(...ponies) &#123; for (let pony of ponies) &#123; poniesInRace.push(pony); &#125;&#125; ponies giờ sẽ trở thành một mảng có thể loop được bằng cách sử dụng for … of. (Đây cũng là một tính năng mới của ES6). Toán tử Rest được sử dụng để lấy list các tham số truyền vào hàm.Toán tử rest cũng có thể áp dụng khi Destructuring dữ liệu 1234const [winner, ...losers] = poniesInRace;// poniesInRace là một mảng chứa nhiều pony// 'winner' sẽ chứa pony đầu tiên// và 'losers' sẽ là một mảng của các phần tử còn lại Toán tử Spread …Trong khi Rest sử dụng để cấu thành nhiều biến riêng biệt thành một mảng đơn lẻ, thì spread lại mang ý nghĩa ngược lại là phân tách 1 mảng thành các phần tử riêng lẻ. 12const ponyPrices = [12, 3, 4];const minPrice = Math.min(...ponyPrices); Tobe continued …","categories":[{"name":"memo","slug":"memo","permalink":"https://hieunh161.github.io/categories/memo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hieunh161.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://hieunh161.github.io/tags/es6/"}]},{"title":"Hướng dẫn viết blog","slug":"guideline-hexo","date":"2016-10-20T15:20:04.000Z","updated":"2016-10-23T05:43:14.000Z","comments":true,"path":"2016/10/21/guideline-hexo/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/21/guideline-hexo/","excerpt":"Cài đặt môi trườngBlog sử dụng hexo dựa trên nodejs nên cần cài đặt nodejs cài đặt nodejs cài đặt hexo 1npm install hexo-cli -g","keywords":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/categories/guideline/"}],"text":"Cài đặt môi trườngBlog sử dụng hexo dựa trên nodejs nên cần cài đặt nodejs cài đặt nodejs cài đặt hexo 1npm install hexo-cli -g Get source code từ github clone blog source về máy từ github và cài đặt dependencies 123git clone https://github.com/hieunh161/at-blog.gitcd &#123;thư mục source&#125;npm install Tạo bài viết mới và public lên github Tạo bài viết mới bằng lệnh 12cd &#123;thư mục source&#125;hexo new post &#123;tên bài viết&#125; Vào thư mục source/_posts viết bài bằng markdown.Có thể tham khảo markdown cheatsheet ở đây Commit source lên git sau đó deploy source lên server 1npm run deploy","categories":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/categories/guideline/"}],"tags":[{"name":"guideline","slug":"guideline","permalink":"https://hieunh161.github.io/tags/guideline/"}]},{"title":"Hospitality","slug":"hospitality","date":"2016-10-20T14:20:04.000Z","updated":"2016-10-22T07:26:21.000Z","comments":true,"path":"2016/10/20/hospitality/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/20/hospitality/","excerpt":"1. Hospitality là gì?Hospitality là một từ xuất hiện ở Anh từ khoảng năm 1325 – 1375. Theo từ điển thì nó có nghĩa là việc đối xử một cách thân thiện, tử tế của một người chủ với một người khách hoặc một người lạ nào đó. Ví dụ như câu give a person a hospitality. Nó là một danh từ đếm được, nghĩa là có thể có nhiều hospitalities, tức là có nhiều hành động tử tế. Khi nó du nhập vào Nhật thì người Nhật chấp nhận từ đó với ý nghĩa là nghĩ cho người khác, làm những điều vì người khác, hay đối xử với người khác từ trái tim mình đúng như văn hóa của người Nhật. Và đặc biệt từ này đã trở thành một từ như chỉ về các dịch vụ đặc biệt làm hài lòng khách hàng trong kinh doanh. Khi nói về việc làm một hospitality cho một người nào khác thì người Nhật hiểu rằng hành động đó không chỉ là vì đối phương mà nó còn hàm chứa cả tấm lòng của người thực hiện hành động.","keywords":[{"name":"social","slug":"social","permalink":"https://hieunh161.github.io/categories/social/"}],"text":"1. Hospitality là gì?Hospitality là một từ xuất hiện ở Anh từ khoảng năm 1325 – 1375. Theo từ điển thì nó có nghĩa là việc đối xử một cách thân thiện, tử tế của một người chủ với một người khách hoặc một người lạ nào đó. Ví dụ như câu give a person a hospitality. Nó là một danh từ đếm được, nghĩa là có thể có nhiều hospitalities, tức là có nhiều hành động tử tế. Khi nó du nhập vào Nhật thì người Nhật chấp nhận từ đó với ý nghĩa là nghĩ cho người khác, làm những điều vì người khác, hay đối xử với người khác từ trái tim mình đúng như văn hóa của người Nhật. Và đặc biệt từ này đã trở thành một từ như chỉ về các dịch vụ đặc biệt làm hài lòng khách hàng trong kinh doanh. Khi nói về việc làm một hospitality cho một người nào khác thì người Nhật hiểu rằng hành động đó không chỉ là vì đối phương mà nó còn hàm chứa cả tấm lòng của người thực hiện hành động. 2. Hospitality và dịch vụ (services)Trong kinh doanh người ta hay thường nói rằng chúng ta kinh doanh dịch vụ (services) và các công ty luôn cố gắng rằng mình sẽ phải đưa ra các dịch vụ tốt nhất theo ý hiểu đó là làm hài lòng khách hàng. Và hầu như trong thời đại ngày nay nó như là một điều tất yếu. Ở Việt Nam dù cách hành xử vẫn chưa được tốt, nhưng ko thể phủ nhận xu thế này cũng đang dần dần trở thành một điều tất yếu khi nền kinh tế hội nhập và vận động theo cơ chế thị trường. Khi việc cạnh tranh giữa các công ty ngày một khốc liệt hơn, họ không chỉ cạnh tranh về giá, về chất lượng sản phẩm mà còn về chất lượng dịch vụ cung cấp. Như là lắp đặt tận nơi, giúp đỡ vận chuyển tận nhà …Vậy thì sự khác biệt giữa dịch vụ và hospitality nghĩa là gì? Để làm rõ sự khác biệt chúng ta bắt đầu từ nguồn gốc xuất xứ. Từ service xuất phát từ các từ gốc latin là servus , slane, servant nghĩa là nô lệ hay đầy tớ. Người nhận service chính là người chủ, theo nghĩa quan hệ chủ tớ. Và nó cho thấy việc thể hiện thái độ tôn trọng khách hàng, khách hàng là thượng đế đúng quan điểm của người phương tây. Với từ hospitality thì nó xuất phát từ hospital, hospics, hospice nghĩa là bệnh viện, trại chăm sóc, người chăm sóc. … Từ đó điểm khác biệt lớn nhất của 2 từ nằm ở việc từ hospitality mang khuynh hướng của sự đối xử, chăm sóc, niềm vui khi được làm việc gì đó cho người khác hơn là việc làm vì trách nhiệm. Bạn nên hiểu rằng khi mà ngày xưa việc chăm sóc y tế không phải là dịch vụ như bây giờ, nó còn bao gồm cả tình cảm giữa con người với con người, sự giúp đỡ nhau lúc khó khăn … 3. Các bước cơ bảnVậy chúng ta phải hiểu hospitality là như thế nào. Liệu có mối dung hòa nào giữa hospitality và service không. Để cho dễ hình dung chúng ta sẽ xem hospitality như là 3 giai đoạn của dịch vụ như sau. Giai đoạn 1 của dịch vụĐó là việc người cung cấp dịch vụ phải cung cấp cho người dùng dịch vụ những việc hiển nhiên được yêu cầu trong hợp đồng cung cấp. Ví dụ như chúng ta là những là gia sư khi chúng ta đi dậy thì đương nhiên nghĩa vụ và trách nhiệm của chúng ta là phải dạy cho học sinh kiến thức đầy đủ, phù hợp. Ở đây đó là đương nhiên, đúng theo quy luật cung cầu, vì bố mẹ học sinh đã trả tiền để chúng ta làm việc đấy. Hay như chúng ta vào cửa hàng và mua một chiếc áo, thì khi chúng ta trả giá đầy đủ như đã thỏa thuận, hiển nhiên chúng ta sẽ được sở hữu chiếc áo đó. Giai đoạn 2 của dịch vụĐây là giai đoạn mà mục đích là làm cho khách hàng hài lòng hơn nữa, ở giai đoạn này, ngoài dịch vụ đương nhiên, người cung cấp dịch vụ còn làm thế nào đó để cho khách hàng cảm thấy thoải mái, vui vẻ và mong muốn gắn bó lâu dài với dịch vụ của mình hơn bằng việc tạo ra các ấn tượng tốt, chu đáo và kết quả là làm hài lòng khách hàng. Ví dụ như khi chúng ta vào mua quần áo, thì chúng ta sẽ luôn thấy nụ cười trên môi người bán hàng, luôn thấy họ đon đả, cho phép chúng ta lựa chọn thoải mái, giúp đỡ chúng ta tư vấn các sản phẩm phù hợp … Hầu hết hiện nay có lẽ không có cửa hàng nào ko ý thức được điều này. Nó như là một điều hiển nhiên ở các cty có chất lượng dịch vụ tốt hiện nay. Giai đoạn 3 của dịch vụVới 2 giai đoạn trên, có thể chúng ta đã có một dịch vụ tốt, một lượng khách hàng tiềm năng và một khoản khách thường xuyên kha khá. Vì chúng ta luôn làm khách hàng hài lòng, làm họ cảm thấy họ là thượng đế. Vậy thì giai đoạn 3 này là gì nữa, và đây chính là giai đoạn để một service trở thành một hospitality. Ở giai đoạn này không những làm khách hàng cảm thấy hài lòng về dịch vụ, người cung cấp dịch vụ còn phải suy nghĩ nghiêm túc về sở thích, những điều khách hàng thích, và những điều khách hàng mong muốn. Từ đó cung cấp cho khách hàng những điều vượt quá sự mong đợi của họ. Với người Nhật họ thường hay nói đó chính là việc xem những khách hàng như những người thân, dành tình cảm để làm cho họ như tình cảm với gia đình mình, cung cấp cho họ dịch vụ như họ là cha mẹ, anh em, bạn bè của mình. Từ đó để có thể hiểu thấu khách hàng, đưa cho họ một dịch vụ tuyệt vời nhất họ có được. Ví dụ như với mỗi người khách vào mua áo, người bán hàng không những tư vấn để mua hàng của mình, mà phải tư vấn làm sao để khách hàng mua được sản phẩm tốt nhất, hợp lý nhất, ưng ý nhất. Như thể mình bán cho người thân của mình, thì đó chính là điều mà hospitality nói đến.Nói đến 3 giai đoạn này bạn có thể hiểu một câu chuyện vui nhưng rất thật về tính cách 3 con người, Việt Nam, Pháp và Nhật. Câu chuyện nói rằng, khi người Việt Nam buồn, họ sẽ vác bộ mặt đó lên công ty và đối xử với khách hàng với bộ mặt đó, như thể khách hàng là nơi xả nỗi bực tức của họ. Người Pháp thì dù vui hay buồn, họ lúc nào cũng tươi cười với khách hàng. Với người Nhật khi khách hàng buồn, dù họ có đang vui họ cũng sẽ buồn cùng với khách hàng, khi khách hàng vui họ sẽ vui cùng với khách hàng. Đó chỉ là một câu chuyện nhưng thực tế chính là tính cách của 3 con người ở 3 nơi. Việt Nam, Nhật, phương Tây. Hơn thế nữa nó áp dụng rất chính xác vào 3 giai đoạn của một dịch vụ. Người Việt Nam ở giai đoạn 1, phương tây ở giai đoạn 2 và người Nhật ở giai đoạn 3. Nếu bạn đọc báo nhiều về đức tính của người Nhật hoặc đất nước Nhật bạn sẽ hiểu tại sao Nhật được xem là đất nước có dịch vụ tốt nhất thế giới.Các công ty trên thế giới đang chạy đua với nhau không chỉ về chiến lược, sản phẩm … mà quan trọng hơn hết là về chất lượng dịch vụ. Apple sẽ không thể thành công nếu chất lượng dịch vụ khôn tốt. Điều đó là rõ ràng và hiển nhiên.","categories":[{"name":"social","slug":"social","permalink":"https://hieunh161.github.io/categories/social/"}],"tags":[{"name":"soft-skill","slug":"soft-skill","permalink":"https://hieunh161.github.io/tags/soft-skill/"}]},{"title":"Các định luật phần mềm – Phần 3","slug":"software-principle-3","date":"2016-10-19T09:49:56.000Z","updated":"2016-10-23T09:57:18.080Z","comments":true,"path":"2016/10/19/software-principle-3/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/19/software-principle-3/","excerpt":"Định luật KerckhoffsTrong lĩnh vực mã hóa có một định luật được phát biểu bởi Auguste Kerkhoffs nói rằng: In cryptography, a system should be secure even if everything about the system, except for a small piece of information — the key — is public knowledge.Một hệ thống phải được an toàn ngay cả khi kẻ thù biết được tất cả mọi thứ về hệ thống trừ một thứ đó là key mã hóa. Định luật này xuất phát từ thế kỷ 19 và nó dường là tiền đề cho mọi phát minh về mã hóa sau này. Trong thế chiến thứ 2 khi mà hoạt động tình báo trở nên vô cùng phổ biến và cuộc chiến về mã hóa đã cho ra đời hàng trăm phát minh mới về mã hóa trong thời gian này thì định luật này được xem như là cơ sở. Và hiện nay với các mã hóa hiện đại càng thể hiện sự đúng đắn của định luật này.","keywords":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"text":"Định luật KerckhoffsTrong lĩnh vực mã hóa có một định luật được phát biểu bởi Auguste Kerkhoffs nói rằng: In cryptography, a system should be secure even if everything about the system, except for a small piece of information — the key — is public knowledge.Một hệ thống phải được an toàn ngay cả khi kẻ thù biết được tất cả mọi thứ về hệ thống trừ một thứ đó là key mã hóa. Định luật này xuất phát từ thế kỷ 19 và nó dường là tiền đề cho mọi phát minh về mã hóa sau này. Trong thế chiến thứ 2 khi mà hoạt động tình báo trở nên vô cùng phổ biến và cuộc chiến về mã hóa đã cho ra đời hàng trăm phát minh mới về mã hóa trong thời gian này thì định luật này được xem như là cơ sở. Và hiện nay với các mã hóa hiện đại càng thể hiện sự đúng đắn của định luật này. Định luật Reed The utility of large networks, particularly social networks, scales exponentially with the size of the network.Độ mở rộng của các mạng xã hội tỉ lệ với hàm số mũ Được phát biểu bởi David Reed nói về mức độ phát triển của một mạng lớn, đặc biệt là mạng xã hội. Lý do tại sao lại là hàm số mũ mà ko phải hàm bình phương là vì số nhóm con của một mạng xã hội có N thành viên sẽ là 2^N − N − 1, nó tăng nhanh hơn rất nhiều so với số lượng connection chỉ là N(N-1) (Định luật Metcalfe) Định luật ZawinskiĐịnh luật nói về độ mở rộng của một phần mềm Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.Tất cả các chương trình sẽ được mở rộng cho tới khi nó đọc được mail, những chương trình ko đạt được điều đó sẽ được thay thế bởi chương trình có thể làm được. Nó nói lên mức độ phổ biến và sự quan trọng của mail trong hệ thống thông tin. Hầu như ngày nay tất cả các chương trình đều liên kết tới email, không có chương trình nào mà ko sử dụng địa chỉ email để đăng ký cả. Hiện nay có một dị biến nói thêm về RSS nhưng ko phổ biến. Hiện tại email vẫn là số 1 trong tất cả các hệ thống. Định luật ConwayMột định luật vô cùng quan trọng thể hiện sự phản ánh cấu trúc của phần mềm Any piece of software reflects the organizational structure that produced itBất kỳ phần nào của phần mềm cũng phản ánh cấu trúc đã tạo ra nó Đây là định luật được Conway đưa ra vào năm 1968 về cấu trúc hệ thống phần mềm. Nó cho phép bạn có thể hiểu được cách thức, cấu tạo của hệ thống khi biết được một phần của phần mềm. Nó là hệ quả của việc nhiều người cùng làm trong cùng một hệ thống. Giả sử A và B làm 2 modul 1 và 2 thì để 1 và 2 kết nối được với nhau thì A và B phải tạo ra interface để các module ấy có thể nói chuyện được với nhau. Hoặc giả sử A làm một module và nếu B muốn dùng module đó thì trong OO B thường sẽ extend module của A vì sợ làm ảnh hưởng tới code của A, tuy nhiên nếu A thêm chức năng có thể A sẽ sửa trực tiếp module chứ ko phải extend nó. Đó chính là ý mà conway muốn nói đến trong định luật này. Định luật FittĐây là định luật về độ usability của hệ thống. Time = a + b log2 ( D / S + 1 ) phát biểu bằng lời như sau The time to acquire a target is a function of the distance to and the size of the target.Thời gian để đạt được một mục tiêu là hàm phụ thuộc vào khoảng cách và kích thước của mục tiêu Nó ảnh hưởng rất lớn đến các nhà thiết kế. Kể ra thiết kế các module để reuse trong phần mềm hay là thiết kế giao diện. Ví dụ như việc đặt menu ở góc trái bên dưới là vị trí sẽ tốn thời gian nhất. Vì khoảng cách xa và diện tích bé. Dấn tới sẽ tốn thời gian để bạn có thể thao tác với menu. Ngược lại nếu bạn muốn module nào dễ thao tác, bạn có thể làm diện tích to và đặt ở trung tâm. Định luật này hầu hết các designer đều rất thông thạo. Định luật HickĐịnh luật liên quan tới thời gian đưa ra quyết định cho bạn, được phát biểu như sau. The time to make a decision is a function of the possible choices he or she has.Thời gian đưa ra quyết định sẽ là một hàm phụ thuộc các khả năng lựa chọn mà bạn cóTime = b log2(n + 1) Thời gian sẽ phụ thuộc vào hàm số log cơ số 2. Tại sao lại là log cơ số 2 thì đó chính là do cơ chế não của chúng ta phân tích theo nhị phân. Thường thì chúng ta sẽ làm theo cơ chế loại bỏ. Và chính vì thế có công thức trên. Áp dụng công thức này bạn cũng có thể tính được thời gian để não nhận ra đáp án cho câu hỏi chắc nghiệm. Giả sử đề thi của bạn có 4 câu trả lời khả dĩ. Bạn mất 2 giây để đọc hiểu câu hỏi, thời gian não bạn đưa ra quyết định dựa trên một sự kiện là 0.1s. (Chú ý đây là thời gian não phản ứng. Thông thường khi có tai nạn chẳng hạn, thời gian để não đưa ra phản ứng sau khi nhận biết có sự kiện cũng khoảng 0.1s) và đưa vào công thức bạn sẽ có thời gian để bạn biết câu trả lời của câu hỏi là 2.35s. Và nó cũng có thể mở rộng ra với việc đưa ra quyết định của một nhóm bạn. Tuy nhiên hệ số sẽ khác. Bạn thử áp dụng vào thực tế khi cả nhóm bạn quyết định trưa nay đi ăn ở đâu thử xem. Cũng là một việc thú vị đấy chứ. Định luật Occam RazorĐịnh luật phát biểu rằng The explanation of any phenomenon should make as few assumptions as possibleSự giải thích cho bất kỳ hiện tượng nào nên đơn giản nhất có thể.Định luật này nhấn mạnh rằng cách giải thích nào đơn giản nhất thường là cái đúng. Các nhà thám tử dùng định luật này để loại bỏ dần các đối tượng tình nghi, các bác sĩ dùng định luật này để tìm ra nguyên nhân bệnh dựa trên một tập các triệu chứng. Bạn có thể xem thêm ở đây để hiểu thêm về định luật này. Ngoài các định luật đã nêu còn rất nhiều định luật khác nữa bạn có thể tham khảo ở wiki. Nó bao gồm rất nhiều định luật từ vật lý , toán học, hóa học, sinh học …. khác nữa.","categories":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"tags":[{"name":"principle","slug":"principle","permalink":"https://hieunh161.github.io/tags/principle/"},{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/tags/production/"}]},{"title":"Các định luật phần mềm – Phần 2","slug":"software-principle-2","date":"2016-10-19T08:54:17.000Z","updated":"2016-10-23T09:57:14.946Z","comments":true,"path":"2016/10/19/software-principle-2/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/19/software-principle-2/","excerpt":"Định luật murphyMột định luật vô cùng nổi tiếng khác mà có lẽ tất cả mọi người đều biết, nhưng không phải ai cũng hiểu rõ về nó đó chính là định luật murphy. Được phát biểu như sau: If anything can go wrong, it will.Nếu một việc có thể diễn tiến xấu, nó sẽ diễn tiến đúng như thế","keywords":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"text":"Định luật murphyMột định luật vô cùng nổi tiếng khác mà có lẽ tất cả mọi người đều biết, nhưng không phải ai cũng hiểu rõ về nó đó chính là định luật murphy. Được phát biểu như sau: If anything can go wrong, it will.Nếu một việc có thể diễn tiến xấu, nó sẽ diễn tiến đúng như thế Định luật này còn được gọi là Định luật bánh bơ và được được nhận giải IG nobel vào năm 2003. Nó được chuyên gia tên lửa A. Murphy phát biểu vào năm 1949 . Nó nguồn gốc từ một nghiên cứu của không quân Mỹ về tác dụng của quá trình giảm tốc nhanh trên các phi công. Người tình nguyện bị buộc trong xe trượt tuyết gắn động cơ phản lực, và phản ứng của họ khi xe dừng đột ngột sẽ được ghi lại nhờ hệ thống điện cực gắn khít vào bộ ghế ngồi do đại úy Edward A. Murphy thiết kế. Tuy nhiên, Murphy đã không ghi được số liệu nào sau một thử nghiệm tưởng chừng không có sai sót. Thì ra, một điện cực bị mắc sai. Sai lầm hy hữu này khiến Murphy phải thốt lên: “Nếu trong nhiều cách có một cách sai – sẽ có người thực hiện cách sai đó”. Đã bao giờ bạn đi ra đường, đến công ty và gặp cảnh tắc đường, bạn thấy như thế và quyết định rằng sẽ chọn một con đường vòng mà có khả năng nhanh hơn, tuy nhiên vẫn lo ngại rằng có thể nó cũng bị tắc, và thực tế rằng con đường mới bạn chọn cũng tắc khiến bạn có thể còn chậm hơn. Hoặc có rất nhiều lần những điều bạn lo sợ đã xảy ra. Tôi tin rằng điều đó với ai cũng có. Có nhiều người cho rằng đó là định luật chi phối mọi thứ. Vậy liệu nó có bí ẩn gì đằng sau không. Và có rất nhiều người sau khi trải qua một vài điều như thế bắt đầu tin vào số mệnh. Vậy sự thật là gì? Chúng ta sẽ nhìn định luật murphy dưới con mắt của các nhà khoa học như sau: Sau một nghiên cứu và cố gắng định lượng phương trình murphy, joel pel đã đưa ra phương trình như trên. Trong đó: PM là khả năng murphy mà một điều gì đó sẽ không đúng. KM là hằng số murphy, nó là một hằng số bằng 1. FM là hệ số murphy, nó là một số rất nhỏ, nhưng chúng ta có làm tròn xấp xỉ nó bằng 0.01. Các hệ sô I,C,U,F là các biến có thang đo từ 1-10 để miêu tả về sự kiện. Trong đó, I là độ quan trọng của kết quả hoặc kết quả sự kiện, C là độ phức tạp của hệ thống, U là mực độ khẩn cấp của hệ thống. F là mức độ thường xuyên sử dụng hệ thống. Từ 4 biến đó mà bất kỳ sự kiện nào cũng có thể mô tả được. Và với các giá trị đã cho bạn có thể tự tính được khả năng mà một sự việc có thể không đúng. Trong lĩnh vực phần mềm, định luật murphy ảnh hưởng nhiều nhất trong các phase : project planning, performance management, progress management, risk assesment … và nếu bạn nghĩ rằng nó chỉ có thể xảy ra ở những bước trên thì nó sẽ sai ở một bước khác nữa. Ý nghĩa của định luật murphy chính là những hiểm họa sẽ xảy ra ngay cả khi bạn không tiên đoán được. Để kết thúc về định luật murphy chúng ta sẽ thử áp dụng công thức murphy vào một số ví dụ minh họa sau: Giả sử bạn đang code cho một module của hệ thống, module này là một module rất quan trọng, vì nó được gọi bởi rất nhiều module khác (ví dụ như thao tác với dữ liệu bao gồm CRUD chẳng hạn, hoặc gì đó tùy bạn), và vì thế mà nó rất thường xuyên được gọi trong hệ thống của bạn. Vậy chúng ta thử đánh giá xem, khả năng module này của bạn code liệu có thể có xảy ra lỗi khi đưa vào sử dụng hay không. Độ quan trọng của hệ thống ta cho I = 9 (1 là thấp nhất, 10 cao nhất), module này giả sử tuy quan trọng nhưng ko đến nỗi quá phức tạp, ta cho là 5, và nó cần hoạt động trước khi các module khác hoạt động, ví dụ như bạn phải insert thì mới xử lý và trả kết quả về được, nên ta cho nó là 8, và cuối cùng nó rất hay được gọi nên độ thường xuyên là 9. Vậy áp dụng các công thức trên thì xác suất murphy sẽ là gần bằng 1. Nghĩa là chắc chắn sẽ có lỗi xảy ra với module của bạn khi đưa vào hoạt động, hoặc trong các điều kiện xấu. Tương tự như thế, bạn có thể tự điều chỉnh dữ liệu và sự kiện để có thể áp dụng vào các trường hợp khác. Trong lập trình có một trường phái lập trình để chống lại định luật murphy đó chính là lập trình phòng thủ. Ai có thời gian có thể tìm hiểu thêm. Định luật Brook Adding manpower to a late software project makes it later.Nếu thêm người vào một dự án chậm sẽ làm nó chậm hơn Nó được Brook là một quản trị dự án lâu năm ở IBM đúc kết ra sau rất nhiều dự án ông đã làm ở IBM, và được viết trong cuốn sách cũng vô cùng nổi tiếng The mythical man-month xuất bản năm 1975. Giờ đây định luật này nằm trong hầu hết các cuốn sách về quản trị lớn bé trên thế giới về phát triển phần mềm. Ông còn phát biểu nó dưới dạng một câu nói khác vô cùng hài hước: The bearing of a child takes nine months, no matter how many women are assigned.Không có cách nào để 9 bà mẹ có thể sinh ra một đứa trẻ trong 1 tháng. Có 2 điểm dùng để giải thích cho định luật brook trong phát triển phần mềm đó là: Sẽ mất một thời gian nhất định để người thêm vào dự án có thể quen với công việc. Dự án phần mềm là một công việc phức tạp, nhất là những dự án khó về mặt business, và những người mới thường phải đầu tiên là được đào tạo để làm quen với nó. Việc đào tạo này cũng yêu cầu tài nguyên từ dự án, như yêu cầu PM hoặc những người có kinh nghiệm đào tạo. Chính việc này đến lượt nó lại làm mất năng suất làm việc của những người có kinh nghiệm nó trên vì họ tốn thời gian vào đào tạo. Ngoài ra những người mới có thể còn làm tiến độ chậm đi khi họ có khả năng tạo ra các bugs mới cho hệ thống. Thứ 2 là sự tăng nhanh về kênh giao tiếp giữa các thành viên. Số kênh giao tiếp khác nhau có thể tăng nhanh với số người tham gia. Nó khiến cho công việc khó có thể được đồng bộ, và có thể chồng chéo, làm chậm trễ hơn. Tuy nhiên cũng có một số điểm có thể xem xét khi thêm người, đó là thêm vào giai đoạn sớm của dự án hoặc người thêm vào thực sự có kinh nghiệm, có khả năng. Định luật LinusĐược đặt tên theo Linus Torvalds người đã phát triển hệ điều hành linux, được phát biểu như sau: Given enough eyeballs, all bugs are shallowNếu có đủ số lượng người , thì số lượng bugs sẽ giảm đi. Linus là một trong những thiên tài trong phần mềm, ông đã phát triển nền tảng cho linux và đưa open code cho tất cả lập trình viên trên thế giới phát triển nó, chỉnh sửa và thêm vào. Tốc độ của hệ thống nhân linux ngày càng nhanh cùng với số lượng người tham gia phát triển nó. Enough eyeballs ở đây thể hiện cho số người làm việc và tham gia giải quyết vấn đề. Một phát biểu thông thường hơn của định luật linus là : Với một lượng đủ lớn các lập trình viên và các tester, hầu hết tất cả các vấn đề sẽ được xác định và sửa một cách nhanh chóng và dễ dàng. Định luật moore The power of computers per unit cost doubles every 24 month.Khả năng xử lý của máy tính trên mỗi đơn vị sẽ tăng gấp đôi sau mỗi 2 năm Hay Số lượng Transitor trên mỗi đơn vị inch vuông sẽ tăng lên gấp đôi sau mỗi năm Một định luật nổi tiếng khác mà hầu như ai cũng từng nghe đến, Định luật Moore lần đầu tiên được công bố rộng rãi trên tạp chí Electronics Magazine số ra ngày19/4/1965. Định luật Moore là một bước ngoặt lớn trong ngành công nghệ điện tử, giải thích tại sao nhà sản xuất có thể giảm giá thành trong khi vẫn tiếp tục nâng cao hiệu suất của phần cứng. Tuy nhiên, trong thời gian gần đây định luật Moore đã có nhiều biểu hiện bị thay đổi và kéo dài dần thời gian tăng đôi số transtior trên một đơn vị diện tích (một inch vuông). Tại thời điểm hiện nay (năm 2007), khoảng thời gian để tăng đôi số transistor là xấp xỉ 60 tháng. Nhiều nhà phân tích cho rằng trong tương lai không xa khi mà các áp dụng kỹ thuật đã không thể rút nhỏ kích cở của một transistor xuống hơn được (cụ thể là khi kiến trúc của transistor đã được rút xuống đến mức độ phân tử) thì định luật Moore sẽ không còn đúng nữa. Tuy nhiên với khoảng thời gian dài liên tục phát triển của mình, thì những thành tựu rực rỡ của ngành công nghiệp điện tử đã góp phần xây dựng rất nhiều thần kỳ trong thế kỷ vừa qua. Định luật WirthNăm 1995 Niklaus Wirth đưa ra định luật mang tên ông như sau: software is getting slower more rapidly than hardware becomes faster.Phần mềm đang dần nhanh hơn so với phần cứng. Ý nghĩa của định luật wirth là các phần mềm đang dần ngày càng phức tạp, và dần dần các phần cứng trở nên không đáp ứng được với sự phức tạp của nó. Nhất là trong quá trình vật liệu ngày càng khó khăn, thời gian định luật moore ngày càng kéo dài và có thể không còn đúng nữa, thì việc phần mềm vẫn đang phát triển vô cùng chóng mặt. Đơn giản như các hệ điều hành của microsoft, cứ chu kỳ khoảng 2 năm ra một bản, và các bản sau phức tạp hơn, yêu cầu phần cứng khắt khe hơn. Trên phương diện internet có thể hiểu như tốc độ truyền tải dữ liệu hạn chế, trong khi yêu cầu gửi tin video hoặc chất lượng dữ liệu cao thì ngày càng tăng cao. Chính điều đó cũng là một thách thức với ngành công nghiệp phần cứng.","categories":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"tags":[{"name":"principle","slug":"principle","permalink":"https://hieunh161.github.io/tags/principle/"},{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/tags/production/"}]},{"title":"Các định luật phần mềm – Phần 1","slug":"software-principle-1","date":"2016-10-19T08:44:31.000Z","updated":"2016-10-23T09:57:11.000Z","comments":true,"path":"2016/10/19/software-principle-1/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/19/software-principle-1/","excerpt":"Mở đầuTrong các lĩnh vực tự nhiên, các nhà khoa học đã tìm ra rất nhiều định luật, quy luật của tự nhiên và đã trở thành những kiến thức nền tảng trong xã hội. Nó giúp chúng ta hiểu rõ, giải thích được các hiện tượng một cách thấu đáo hơn. Trong lĩnh vực phần mềm, dù nó khác so với một lĩnh vực khoa học, song trong thời gian ngắn xuất hiện của mình, nó cũng đã được rất nhiều nhà nghiên cứu tìm ra được những quy luật và họ đã phát biểu thành các định luật mang tên mình. Hiểu rõ được các định luật chi phối trong ngành phần mềm không chỉ giúp chúng ta hiểu hơn công việc mà còn giúp chúng ta thay đổi xử lý các vấn đề tốt hơn.","keywords":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"text":"Mở đầuTrong các lĩnh vực tự nhiên, các nhà khoa học đã tìm ra rất nhiều định luật, quy luật của tự nhiên và đã trở thành những kiến thức nền tảng trong xã hội. Nó giúp chúng ta hiểu rõ, giải thích được các hiện tượng một cách thấu đáo hơn. Trong lĩnh vực phần mềm, dù nó khác so với một lĩnh vực khoa học, song trong thời gian ngắn xuất hiện của mình, nó cũng đã được rất nhiều nhà nghiên cứu tìm ra được những quy luật và họ đã phát biểu thành các định luật mang tên mình. Hiểu rõ được các định luật chi phối trong ngành phần mềm không chỉ giúp chúng ta hiểu hơn công việc mà còn giúp chúng ta thay đổi xử lý các vấn đề tốt hơn. Định luật PostelĐịnh luật Postel hay còn gọi là định luật về độ ổn định của một hệ thống (Robustness law) được đặt tên theo nhà khoa học Postel là người tiên phong trong lĩnh vực phát triển nền tảng internet. Ông phát biểu định luật này khi viết đặc tả cho giao thức TCP (transmission control protocol) nổi tiếng. Be conservative in what you send, liberal in what you acceptHãy tuân thủ chặt chẽ những gì bạn gửi đi, tự do với những gì bạn chấp nhận Nói theo một cách khác, code viết trong các chương trình khi gửi lệnh hoặc dữ liệu tới chương trình khác, hoặc module khác của chương trình nên tuân thủ chặt chẽ các đặc tả, tuy nhiên code khi nhận dữ liệu thì phải làm sao nó có thể chấp nhận được cả các dữ liệu không tuân thủ cấu trúc, hoặc ý nghĩa không rõ ràng. Thực tế thì bạn gặp rất nhiều trường hợp liên quan tới định luật Postel như code check lỗi input và handle exception… trong phần mềm. Định luật Parkingson Work expands so as to fill the time available for its completionCông việc luôn tự mở rộng ra để chiếm đủ thời gian được ấn định cho nó Định luật này được C. Northcote Parkinson, nhà văn và sử học người Anh đưa ra. Nó không chỉ dành cho lĩnh vực phần mềm nói riêng mà nó mở rộng cho tất cả các lĩnh vực khác. Ý nghĩa của nó là khi bạn dự định làm một công việc gì đó trong một khoảng thời gian lớn hơn so với thời gian nó có thể hoàn thành thì bản thân công việc sẽ mở rộng ra để chiếm nốt phần thời gian thừa của bạn. Ví dụ như công việc này bạn dự định làm trong 1 tuần, tuy nhiên thực tế thì có thể hoàn thành công việc trong 3 ngày. Vậy khi làm công việc thì nó sẽ phát sinh những việc để chiếm hết 1 tuần của bạn. Định luật này vô cùng quan trọng đối với các nhà quản lý. Hiểu rõ định luật này sẽ giúp các nhà quản lý hoạch định để tăng productivity của nhân viên, cũng như sử dụng thời gian rảnh rỗi một cách hợp lý. Và nó cũng dẫn tới một kiểu quản lý mới đó là các nhà quản lý cố gắng chia nhỏ công việc ra nhỏ nhất có thể để hạn chế tối đa ảnh hưởng của định luật Parkingson. Thường thì có thể là trong 1 ngày. Bạn có thể tự kiểm nghiệm với bản thân mình, thường những cách mà nhân viên áp dụng định luật parkingson là họ cố gắng nghĩ ra những việc không quan trọng để lấp đầy thời gian rảnh rỗi, như sắp xếp giấy tờ, pha cà phê … hoặc những công việc có productivity bằng 0. Định luật này còn áp dụng trong lĩnh vực quản lý tiền bạc với phát biểu sau: Expenditures rise to meet income.Các khoản chi tiêu sẽ tăng lên cho đến khi nó bằng với thu nhập. Nghĩa là nếu bạn ko có kế hoạch tích lũy, quản lý hợp lý tiền bạc thì cho dù thu nhập bạn tăng lên bạn cũng ko có hi vọng gì vào việc có tiền thừa cả, mà sẽ có các khoản chi phí khác phát sinh cho đến khi số tiền bằng với số tiền bạn kiếm được. Với sinh viên và nhân viên trẻ thì điều này thấy rất rõ ràng. Hiểu được định luật parkingson có thể giúp bạn biến nó thành lợi thế cho mình với các định hướng trước như dừng việc dành hàng giờ đồng hồ vào việc làm gì đấy, hãy cố gắng hoàn thành mọi việc càng sớm càng tốt và tận hưởng thời gian rỗi rãi còn lại. Định luật ParetoCòn được biết với định luật vô cùng nổi tiếng 80-20, hay là quy luật thiểu số quan trọng, phân bố nhân tố, nó được phát biểu như sau: For many phenomena, 80% of consequences stem from 20% of the causes.Với rất nhiều hiện tượng, thì 80% kết quả là do 20% nguyên nhân gây ra Nó được đặt tên theo nhà kinh tế người Ý Vilffedo Pareto với công trình đầu tiên về quan sát 80% đất đai ở Ý là thuộc 20% dân số, và sau đó được các nhà nghiên cứu khác áp dụng rộng rãi trong tất cả các hiện tượng trong xã hội. Trong lĩnh vực phần mềm chúng ta có thể hiểu theo một số cách rất quan trọng như sau. 80% khối lượng công việc sẽ do 20% số người làm ra. Hay 80% bugs sẽ đến từ 20% số dòng code… hoặc là 80% khối lượng công việc khó nhất sẽ nằm trong thời gian 20% cuối cùng. Hay đơn giản là 20% sếp sẽ nhận thu nhập bằng 80% chẳng hạn. Trước kia có một lần nói chuyện với một sếp cũ thì có biết là chính sách công ty cũng sẽ là giữ 20% key còn lại thì không quan tâm lắm. Nên dù sao việc của bạn khi hiểu được quy luật này là hãy phấn đấu để trở thành 20% quan trọng nhất ở bất kỳ vị trí nào. :) quy luật này dù hiện hữu ở rất nhiều lĩnh vực nhưng vấn đề của nó là không phải lúc nào bạn cũng biết được cái nào là 20%. Định luật PeterNăm 1968 trong cuốn sách “The peter principle” Dr. Laurence J. Peter đã đưa ra định luật phát biểu rằng: “In a hierarchy every employee tends to rise to his level of incompetence.”Trong mô hình phân cấp, các nhân viên sẽ có xu hướng vươn lên tới các vị trí mà năng lực anh ta không đáp ứng được. Theo như định luật này thì một lúc nào đó, cuối cùng một nhân viên sẽ vươn tới được vị trí mà tất cả khả năng tốt nhất của anh ta được phát huy. Và những vị trí cao hơn thì năng lực của anh ta không còn phù hợp và đáp ứng được nữa. Hoặc nó còn có thể hiểu là dù anh ta còn khả năng nhưng anh ta không còn rèn luyện những kỹ năng để đáp ứng vị trí công việc nữa. Với những công ty phát triển nhanh đột biến thì hiện tượng này xảy ra rất nhiều. khi các sếp hi vọng các nhân viên xuất sắc ở cấp dưới có thể đảm nhiệm tốt các công việc phía trên vì khả năng của họ. Ví dụ những người có năng lực kỹ thuật tốt thường sẽ đảm nhiệm việc quản lý khi cty phát triển. Tất nhiên có nhiều người có khả năng phù hợp, nhưng cũng có những người không thể đáp ứng được. Trong quản trị nhân sự cấp cao, điều này đặc biệt quan trọng. Với quản trị nhân sự chung trong toàn công ty lớn, hiện nay họ cũng cố gắng hạn chế nhất có thể việc “ngồi nhầm chỗ” này khi đánh giá đúng được năng lực nhân viên. Định luật HofstadterĐịnh luật này là một phần của cuốn sách An Eternal Golden Braid của Douglas Hofstadter xuất bản năm 1979. Định luật này đặc biệt đúng, ngay cả áp dụng vào thời gian tôi dành để viết bài blog này. Thời gian để viết xong nó tốn nhiều hơn những gì tôi đã mong muốn. Định luật này phát biểu rằng: It always takes longer than you expect, even when you take into account Hofstadter’s Law.Một nhiệm vụ thường tốn nhiều thời gian hơn bạn mong muốn, ngay cả khi bạn biết và hiểu định luật này. Định luật này được giới thiệu lần đầu tiên liên quan tới vấn đề cuộc chiến cờ giữa máy tính và người khi mà các kỳ thủ hàng đầu đã liên tục đánh thắng máy ngay cả khi máy tính tính toán trước được rất nhiều nước đi của các kỳ thủ. Hofstadter đã viết : “Trong những ngày đầu của cờ máy, người ta đã estimate rằng sẽ mất 10 năm để biến cờ máy thành vô địch, không có đối thủ. Nhưng sau khi 10 năm trôi qua, có vẻ như ngày mà cờ máy thành vô địch sẽ phải mất thêm 10 năm nữa.” Và ông ấy lấy đó như là một luận cứ để hình thành nên định luật của mình. Trong lĩnh vực phần mềm bạn có thể hiểu là thông thường thời gian thực hiện xong một task, module sẽ thường dài hơn bạn đã ước lượng và mong muốn. Định luật này được đề cập và nhắc đến rất nhiều trong các programmers. Trong các cuốn về tăng hiệu suất công việc như The mythical of man-month hay extreme programming vấn đề này cũng được thảo luận rất nhiều. Định luật này phản ánh sự phức tạp trong vấn đề estimate ngay cả với những người có kinh nghiệm. To be continue.","categories":[{"name":"software","slug":"software","permalink":"https://hieunh161.github.io/categories/software/"}],"tags":[{"name":"principle","slug":"principle","permalink":"https://hieunh161.github.io/tags/principle/"},{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/tags/production/"}]},{"title":"The mythical men-day (Phần 3)","slug":"productivity-3","date":"2016-10-18T05:32:54.000Z","updated":"2016-10-23T09:57:04.871Z","comments":true,"path":"2016/10/18/productivity-3/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/18/productivity-3/","excerpt":"Mở đầuCốt lõi của việc tăng hiệu quả sản xuất vẫn là làm thế nào để tăng năng suất lao động. Năng suất lao động là chìa khóa quyết định sự phát triển, bởi vì nếu không thể tăng năng suất lao động có nghĩa là tổ chức của bạn sẽ khó có cơ hội cạnh tranh, khó có cơ hội tăng lợi nhuận, khó có cơ hội đạt được bước nhảy về thu nhập cho nhân viên … Có nhiều công ty chọn cho mình hướng phát triển với việc mở rộng quy mô, mở rộng thị trường. Tất nhiên là việc phát triển mở rộng thị trường nếu thành công là việc phải ưu tiên hàng đầu, thế nhưng nó cũng là những việc gắn liền với quyết định quản trị của các top-manager. Xét trên khía cạnh của những người lao động thực sự, những người chiếm phần lớn trong công ty thì họ sẽ nhận được rất ít hoặc không được lợi gì từ hoạt động mở rộng đó. Bởi vì nếu năng suất không đổi thì người công nhân không có lý do gì để có thể tăng thu nhập. Một công nhân hôm nay sản xuất 10 sản phẩm, và 1 năm sau vẫn công nhân đấy vẫn 10 sản phẩm đấy thì chắc chắn rằng anh ta vẫn sẽ chỉ nhận được số tiền lương giống 1 năm trước. Vậy có thể hiểu định tính rằng, năng suất và giá trị trung bình sẽ là một đại lượng tỉ lệ với nhau. Thông thường nó không phải là một hàm tuyến tính mà nó sẽ là một tỉ lệ cao hơn thậm chí là hàm số mũ vì các ảnh hưởng của năng suất lên khả năng bán hàng, khả năng cạnh tranh của doanh nghiệp. Tuy nhiên để dễ hiểu chúng ta cứ hình dung nó tương tự như dưới đây.","keywords":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"text":"Mở đầuCốt lõi của việc tăng hiệu quả sản xuất vẫn là làm thế nào để tăng năng suất lao động. Năng suất lao động là chìa khóa quyết định sự phát triển, bởi vì nếu không thể tăng năng suất lao động có nghĩa là tổ chức của bạn sẽ khó có cơ hội cạnh tranh, khó có cơ hội tăng lợi nhuận, khó có cơ hội đạt được bước nhảy về thu nhập cho nhân viên … Có nhiều công ty chọn cho mình hướng phát triển với việc mở rộng quy mô, mở rộng thị trường. Tất nhiên là việc phát triển mở rộng thị trường nếu thành công là việc phải ưu tiên hàng đầu, thế nhưng nó cũng là những việc gắn liền với quyết định quản trị của các top-manager. Xét trên khía cạnh của những người lao động thực sự, những người chiếm phần lớn trong công ty thì họ sẽ nhận được rất ít hoặc không được lợi gì từ hoạt động mở rộng đó. Bởi vì nếu năng suất không đổi thì người công nhân không có lý do gì để có thể tăng thu nhập. Một công nhân hôm nay sản xuất 10 sản phẩm, và 1 năm sau vẫn công nhân đấy vẫn 10 sản phẩm đấy thì chắc chắn rằng anh ta vẫn sẽ chỉ nhận được số tiền lương giống 1 năm trước. Vậy có thể hiểu định tính rằng, năng suất và giá trị trung bình sẽ là một đại lượng tỉ lệ với nhau. Thông thường nó không phải là một hàm tuyến tính mà nó sẽ là một tỉ lệ cao hơn thậm chí là hàm số mũ vì các ảnh hưởng của năng suất lên khả năng bán hàng, khả năng cạnh tranh của doanh nghiệp. Tuy nhiên để dễ hiểu chúng ta cứ hình dung nó tương tự như dưới đây. Vậy năng suất là gì?Trong nhiều trường hợp năng suất có thể dễ dàng định nghĩa được, tuy nhiên trong nhiều trường hợp để tìm ra đúng năng suất là gì thì thực sự là một điều khó khăn. Thông thường sẽ có 2 cách để định nghĩa một khái niệm. Một đó là diễn giải khái niệm đó ra theo cách mọi người có thể hiểu, cách thứ 2 đó là đưa ra hiện tượng và gán nó vào. Ở đây tôi sẽ chọn cách thứ 2 và đưa ra 2 ví dụ để biểu thị cho 2 trường hợp điển hình về năng suất, và cách thông thường mọi người suy nghĩ về nó. Case 1 : Trong một nhà máy sản xuất hàng may mặc, thông thường năng suất có thể dễ dàng định nghĩa bằng số lượng sản phẩm may người công nhân sản xuất ra trong một đơn vị thời gian. Chúng ta có thể định nghĩa theo công thức : H = A/t với A là số lượng sản phẩm, t là thời gian sản xuất. Và để tính tiền công cho công nhân trong trường hợp này cũng rất dễ dàng, chúng ta chỉ cần lấy năng suất H nhân với thời gian t người công nhân làm việc. Trong trường hợp này năng suất cũng là một hàm tỉ lệ với sản lượng. Năng suất sẽ tăng khi sản lượng tăng. Case 2: Trong lĩnh vực sản xuất phần mềm, làm thế nào để có thể xác định được năng suất của một developer. Trước kia trong các giáo trình quản trị phần mềm cũng có nêu ra một số cách để xác định như thông qua số lượng module, checkbox tạo ra, hay thông qua số dòng code… Tuy nhiên cách nào cũng đều không hoàn toàn hợp lý. Bởi vì dù dòng code có giống nhau thì chất lượng cũng sẽ khác, và dù cùng tạo một GUI, những cũng có module tạo dễ, module tạo khó. Chính vì thế những ngành khó định lượng thường có những quy luật pareto như 20% nhân viên sẽ tạo ra 80% khối lượng sản phẩm. Những ngành như thế đánh giá productivity của mỗi cá nhân sẽ vô cùng khó, thông thường các nhà quản lý đều đánh giá chung chung định tính và thường cào bằng giá trị của các nhân viên ra. Vì thế cuối cùng trong các lĩnh vực như thế này họ thường hướng tới đánh giá tổng thể của một project, một sản phẩm cụ thể. Cũng có các công ty làm phần mềm thường lấy số lượng dòng code developer code để đo productivity cho sản phẩm của mình. Thế nhưng liệu nó có phải là phương pháp đúng. Theo tôi đó là một cách làm vô cùng sai lầm. Lý do là tổng số dòng code không đánh giá được đúng năng suất của developer, vì nhiều dòng code chưa hẳn đã hiệu quả hơn ít dòng code. Trong các dự án ở các công ty, họ thường cố gắng giảm thiểu tối đa số LOC(Line of code) càng nhiều càng tốt, bởi vì nhiều dòng code có nghĩa bạn sẽ phải typing nhiều hơn, thời gian suy nghĩ ít hơn, tốn thời gian hơn, nhiều code cũng có nghĩa số lượng bug tiềm tàng cũng tăng lên… đồng nghĩa với việc khách hàng sẽ tốn chi phí nhiều hơn. Tất nhiên tiết kiệm ở đây không phải là bạn giảm comment code, viết code tối nghĩa đi, mà nó có thể giảm dựa vào cấu trúc hệ thống tốt hơn, common hóa các module tốt hơn ….Vậy trong trường hợp này chúng ta phải định nghĩa năng suất lao động như thế nào cho đúng. Để đơn giản tôi cho rằng năng suất trong trường hợp này có thể được tính số lượng người cần thiết để có thể hoàn thành một sản phẩm. Vậy năng suất là đại lượng tỉ lệ nghịch với số lượng người cần thiết để phát triển một sản phẩm nào đó. Cùng một sản phẩm mà cần nhiều người phát triển hơn đồng nghĩa với việc năng suất sẽ thấp hơn và ngược lại. Năng suất ở đây là một hàm số tỉ lệ nghịch với số người. Giả sử rằng giá trị của phần mềm làm ra là không đổi (constanst) thì năng suất tăng đồng nghĩa với tỉ suất lợi nhuận của công ty và nhân viên đều tăng. Tất nhiên thực tế cũng sẽ không phải là một đường thẳng vì nó sẽ liên quan tới nhiều vấn đề khác như effort dành cho quản lý, dành cho communication. Nếu bạn nào muốn tìm hiểu hơn về điều này có thể tìm đọc cuốn mythical men-month để hiểu rõ hơn. Ở đây tôi chỉ muốn mô hình hóa cho dễ hiểu. Vậy trong 2 trường hợp chúng ta có thể hiểu sơ qua về năng suất và khái niệm của nó trong các tổ chức. Mỗi trường hợp khác nhau sẽ có những định nghĩa khác nhau về năng suất. Và hầu hết đều theo cách này hay cách khác các nhà quản lý đều cố gắng để có thể đo đạc được. Ảnh hưởng của chất lượngTrong các tính toán về năng suất thường người ta thường ít tính tới yếu tố về chất lượng, bởi vì chất lượng là một đại lượng khó định lượng. Tuy nhiên thực tế thì cần phải hiểu rằng, yếu tố chất lượng cũng là một phần của năng suất. Năng suất thực tế được cấu thành từ 2 yếu tố sản lượng và chất lượng. Mục đích chính của OE là tăng năng suất của hoạt động sản xuất sẽ quay về việc tăng sản lượng và chất lượng. Tôi sẽ phân tích về tác động của chất lượng tới năng suất. Giả sử một người công nhân vẫn may mặc, tuy nhiên vì anh ta may ẩu nên dù sản lượng cao tuy nhiên chất lượng của áo rất kém và khi bán ra bị khách hàng kiểm tra phát hiện ra đường may kém chất lượng, họ phàn nàn và họ đòi trả lại lô hàng bao gồm cả những chiếc áo tốt của các công nhân khác. Vậy trong trường hợp này ảnh hưởng của người đó tới công ty còn nặng nề hơn việc sản lượng của anh ta kém. Thường ở trong bất kỳ lĩnh vực nào, sản lượng và chất lượng là hai đại lượng nghịch với nhau vì thời gian làm việc là một số cố định. Khi chất lượng tăng thì sản lượng có nguy cơ giảm và ngược lại, khi chạy theo số lượng thì chất lượng lại có nguy cơ tụt giảm. Cả hai yếu tố này dù yếu tố nào giảm cũng đều có hại cho công ty và tổ chức. Chính vì thế OE nhấn mạnh tới việc cải thiện cả hai yếu tố. Trong nhiều trường hợp chất lượng sẽ tăng tính cạnh tranh của công ty, đồng thời giúp cho công ty có lợi thế trong việc phân phối, bán hàng. Trong những trường hợp như thế tác động của chất lượng có thể quyết định rất lớn tới khả năng phát triển, khả năng mở rộng của công ty. Quay lại câu chuyện của người Nhật Bản, ngoài việc cố gắng cải tiến tối đa hiệu quả bằng việc dư thừa, lãng phí, tăng sản lượng bằng việc cơ giới hóa. Người Nhật cũng luôn cố gắng giảm thiểu tối đa lỗi, đưa ra những quy trình tối ưu để có thể cung cấp những sản phẩm chất lượng tốt nhất. Hơn thế họ cũng không ngừng áp dụng kỹ thuật công nghệ để có thể đưa ra những sản phẩm đi trước đối thủ của mình. Dù khởi đầu thua xa những người phương Tây, nhưng trong những thập kỷ qua đã rất nhiều lần người Nhật đi trước phương Tây về mặt công nghệ, như công nghệ thép, công nghệ oto mà điển hình những năm 90 của thế kỷ trước. Điều đó nhấn mạnh rằng, việc áp dụng OE tăng năng suất lao động là hoạt động tổng hợp bao gồm nhiều yếu tố, và nó phải phát triển toàn diện, không chỉ ở cấp quản lý, cấp nhân viên, không chỉ ở các bộ phận riêng lẻ, mà nó cần phải là một tinh thần của cả một công ty, một tổ chức. Trong trường hợp nước Nhật, tinh thần đó có lẽ là còn cả của một dân tộc, khi nói tới nước Nhật là người ta nói tới lao động và nói tới tinh thần cải tiến không ngừng của họ. Năng suất dưới góc nhìn giá trịChúng ta vừa đã đi qua 2 ví dụ về năng suất ở trên, và chúng ta cũng vừa nói qua về ảnh hưởng của năng suất, vậy liệu có cách nào có thể định nghĩa và xác định chính xác năng suất là gì, liệu có cách nào có thể định nghĩa chung nhất cho khái niệm năng suất. Theo bản thân tôi câu trả lời chính là khái niệm dưới góc nhìn giá trị, góc nhìn theo quan điểm của các nhà kinh tế học. Xã hội bản chất nó là sự vận động theo quy luật kinh tế, giá trị được hình thành từ thị trường giữa người bán và người mua, bạn tăng năng suất có nghĩa là bạn sẽ tạo ra nhiều giá trị hơn. Và vấn đề là cần phải có người trả giá để xác định cho giá trị ấy. Năng suất sẽ được định nghĩa bằng giá trị trên một đơn vị thời gian. Nếu bạn làm ra một sản phẩm tuy nhiên không ai trả tiền để mua nó, hoặc nó không có giá trị gì thì cũng có thể xem như năng suất bằng 0. Tất nhiên cũng có những đồ vật hiện tại có thể không có giá, nhưng càng lâu càng có giá như đồ cổ thì đó lại là một vấn đề khác. Ở đây tôi chỉ muốn bàn đến mặt sản xuất ở các doanh nghiệp. Khảo sát nó dưới góc độ những gì tôi hiểu được. Vậy bạn sẽ thấy nếu nhìn vào công thức thì câu chuyện sẽ chuyển về bài toán làm thế nào để tăng hiệu quả, năng suất lao động thành làm thế nào để tăng giá trị bạn làm ra. Bởi vì biến số thời gian là không đổi cho tất cả các công ty, các tổ chức. Nó là một biến số công bằng nhất khi ai cũng có 24h. Ở đây chúng ta lại thấy một bài toán điển hình của tất cả các công ty. Đó là câu hỏi trong các giáo trình kinh tế, mục đích hoạt động của công ty là gì. Câu trả lời thong thường là tối đa hóa lợi nhuận hay tối đa hóa cổ tức của cổ đông. Nó thực chất chính là tăng giá trị V ở phương trình trên. Vậy theo một cách nào đó, vấn đề mục đích kinh doanh của tổ chức cũng gắn liền với việc tăng năng suất lao động. Khi định nghĩa năng suất là giá trị tạo ra trên đơn vị thời gian thì chúng ta có thể nhận ra để tăng năng suất lao động nó sẽ không chỉ bao gồm tăng sản lượng, tăng chất lượng và đồng thời còn tăng hàm lượng chất sám, tăng tính sáng tạo,… nhằm tối đa hóa giá trị sản phẩm làm ra. Bạn có thể tối đa hóa nó bằng cách marketing để tăng được giá bán thì nó cũng tương đương nhau, bởi vì xét trên khía cạnh thị trường thì bản chất giá trị được định bởi quy luật cung cầu. Quy luật này phát biểu rằng thông qua sự điều chỉnh của thị trường, một mức giá cân bằng (còn gọi là mức giá thị trường) và một lượng giao dịch hàng cân bằng (lượng cung cấp bằng lượng nhu cầu) sẽ được xác định. (như hình dưới) Chính vì thế, trên khía cạnh giá trị, mục tiêu tăng năng suất đồng nghĩa với việc tối ưu hóa giá trị hàng hóa, dịch vụ bán ra. Đứng trên khía cạnh đó thước đo dễ nhìn thấy nhất của năng suất đối với một đất nước đó chính là thu nhập bình quân đầu người. Đó là ý nghĩa rộng của năng suất. Tóm lại từ những điều ở trên chúng ta có thể tóm tắt lại rằng. Bản chất tăng năng suất theo nghĩa hẹp sẽ bao gồm tăng chất lượng và sản lượng, theo nghĩa rộng nó sẽ là tối đa hóa giá trị hàng hóa làm ra, dịch vụ cung cấp được. Khi theo hướng tối đa hóa giá trị thì việc tăng năng suất không chỉ bao gồm việc tăng sản lượng, chất lượng dịch vụ mà nó còn liên quan tới các hoạt động tối đa hóa giá trị hàng hóa như marketing, sale …. Năng suất cũng là một đại lượng đo được nếu dưới góc nhìn giá trị. Theo nghĩa đó, năng suất có thể hiểu chính là giá trị trung bình một đơn vị sản xuất làm ra được trong một đơn vị thời gian.","categories":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"tags":[{"name":"productivity","slug":"productivity","permalink":"https://hieunh161.github.io/tags/productivity/"}]},{"title":"The mythical men-day (Phần 2)","slug":"productivity-2","date":"2016-10-18T05:07:42.000Z","updated":"2016-10-23T09:57:01.813Z","comments":true,"path":"2016/10/18/productivity-2/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/18/productivity-2/","excerpt":"Mở đầuỞ thế giới nào cũng có những quy luật riêng của nó, có những nguyên tắc chúng ta không nhất thiết phải hiểu tuy nhiên cũng có những điều cần phải hiểu và không thể bỏ qua. Cũng như thế giới tự nhiên xung quanh chúng ta có bao hiện tượng, chúng ta vẫn có thể sống tốt mà không cần phải hiểu tất cả chúng. Tuy nhiên khi chúng ta hiểu được cơ chế của các hiện tượng tự nhiên đó, chúng ta sẽ biết được điều nào có thể lợi dụng để tạo ra lợi ích cho mình, điều nào là tránh và cách tránh ra sao là hiệu quả.Rất nhiều những thành tựu nổi bật của con người đều bắt đầu bằng việc chúng ta hiểu được gốc rễ của sự việc, nắm rõ được cơ chế và hiện tượng của nó, lợi dụng chúng và phát triển cho mục đích của con người. Ví dụ chúng ta biết cách lắp một thanh kim loại làm cột chống sét khi biết rõ bản chất sét là một dòng điện lớn , biết cách biến dòng nước thành thủy điện khi đã hiểu cơ chế biến đổi năng lượng, hay như khi chúng ta hiểu rõ rằng bản chất của bất cứ file máy tính nào đều được cấu tạo từ binary, thì khi so sánh các file giống nhau hay không cách đơn giản nhất không phải là mở file ra và so sánh từng page với nhau mà chúng ta có thể tính checksum tổng số binary của các file đó để so sánh một cách nhanh chóng nhất…. OE cũng như thế, hàng ngày có thể bạn vẫn không ngừng cải tiến, bạn vẫn cố gắng để làm mọi việc tốt hơn, tuy nhiên để có thể cải tiến hoạt động OE hiệu quả ở doanh nghiệp và tổ chức mình đang làm việc. chúng ta cũng nên hiểu rõ tường tận OE là gì, và nó có những nguyên lý, bản chất nền tảng nào không, tại sao chúng ta lại cần phải hiểu và áp dụng nó, khi đó dù gặp bất cứ điều gì xảy ra, chúng ta cũng có thể dễ dàng giải thích, giải quyết, và thuyết phục những người khác cùng tham gia OE với mình.","keywords":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"text":"Mở đầuỞ thế giới nào cũng có những quy luật riêng của nó, có những nguyên tắc chúng ta không nhất thiết phải hiểu tuy nhiên cũng có những điều cần phải hiểu và không thể bỏ qua. Cũng như thế giới tự nhiên xung quanh chúng ta có bao hiện tượng, chúng ta vẫn có thể sống tốt mà không cần phải hiểu tất cả chúng. Tuy nhiên khi chúng ta hiểu được cơ chế của các hiện tượng tự nhiên đó, chúng ta sẽ biết được điều nào có thể lợi dụng để tạo ra lợi ích cho mình, điều nào là tránh và cách tránh ra sao là hiệu quả.Rất nhiều những thành tựu nổi bật của con người đều bắt đầu bằng việc chúng ta hiểu được gốc rễ của sự việc, nắm rõ được cơ chế và hiện tượng của nó, lợi dụng chúng và phát triển cho mục đích của con người. Ví dụ chúng ta biết cách lắp một thanh kim loại làm cột chống sét khi biết rõ bản chất sét là một dòng điện lớn , biết cách biến dòng nước thành thủy điện khi đã hiểu cơ chế biến đổi năng lượng, hay như khi chúng ta hiểu rõ rằng bản chất của bất cứ file máy tính nào đều được cấu tạo từ binary, thì khi so sánh các file giống nhau hay không cách đơn giản nhất không phải là mở file ra và so sánh từng page với nhau mà chúng ta có thể tính checksum tổng số binary của các file đó để so sánh một cách nhanh chóng nhất…. OE cũng như thế, hàng ngày có thể bạn vẫn không ngừng cải tiến, bạn vẫn cố gắng để làm mọi việc tốt hơn, tuy nhiên để có thể cải tiến hoạt động OE hiệu quả ở doanh nghiệp và tổ chức mình đang làm việc. chúng ta cũng nên hiểu rõ tường tận OE là gì, và nó có những nguyên lý, bản chất nền tảng nào không, tại sao chúng ta lại cần phải hiểu và áp dụng nó, khi đó dù gặp bất cứ điều gì xảy ra, chúng ta cũng có thể dễ dàng giải thích, giải quyết, và thuyết phục những người khác cùng tham gia OE với mình. Vậy OE là gì?Theo định nghĩa của các nhà quản trị học thì OE là đại lượng dùng để nói về cấp độ hiệu quả của hoạt động sản xuất của tổ chức hiện tại trong việc tối đa hóa đầu ra và tổi thiểu hóa tài nguyên đầu vào, tăng tốc độ phát triển sản phẩm nhanh hơn, đồng thời giảm thiểu lỗi, tăng chất lượng sản phẩm. Nó bao gồm các hoạt động liên quan tới giảm thiểu chi phí, giảm lãng phí thời gian, năng lượng, tăng hiệu quả tài chính, kiểm soát chất lượng … Nói một cách khái quát OE liên quan tới tất cả các mặt của hoạt động sản xuất với mục đích làm cho hoạt động sản xuất tốt hơn.Bạn đang là một developer, vậy bạn cần phải làm gì để công việc bạn tốt hơn? Bạn là một nhà quản lý, vậy bạn phải làm gì để công việc quản lý dễ dàng, hiệu quả hơn. Tìm hiểu về OE sẽ cho phép chúng ta trả lời một cách định tính về hướng tiếp cận và các bước cần làm để hướng tới điều đó. Mô hình OEHoạt động OE thông thường được chia ra thành 4 bước nối tiếp và liên tục, chúng tạo thành một chu trình khép kín và hoạt động như sau. Trước khi đi vào tìm hiểu rõ hơn về mô hình OE chúng ta có hai khái niệm trọng tâm cần phải làm rõ đó là chức năng và quy trình. Chức năng có thể hiểu đó là những đơn vị cơ bản công việc của tổ chức, các chức năng có thể kết hợp trực tiếp với nhau để tạo ra sản phẩm, hoặc hỗ trợ các chức năng khác. Thường các chức năng được chia dựa theo yêu cầu đặc thù của từng tổ chức, nó thường được chia theo hướng chuyên môn hóa mà các hoạt động tương đồng của tổ chức có thể nhóm lại được với nhau. Ví dụ như một nhà máy sản xuất ô tô có thể chia thành bộ phận bán hàng, bộ phận nghiên cứu, bộ phận phát triển… trong bộ phận phát triển có thể chia nhỏ ra thành bộ phận chế tạo bánh, chế tạo phanh, chế tạo động cơ, chế tạo cửa, bộ phận lắp ráp … Đó là dựa trên chức năng bộ phận của o tô. Mục tiêu của chức năng là chia làm sao để nó có thể chuyên môn hóa cao nhất có thể. Bộ phận càng chuyên môn hóa cao, càng tối ưu thì hiệu quả công việc càng cao. Quy trình chính là sự kết hợp của các chức năng, quy định thứ tự của chúng với mục tiêu làm cho công việc diễn ra trơn tru, các bước không bị chồng chéo tránh hiện tượng các bộ phận trong tình trạng rỗi rãi chờ việc. Đồng thời tối đa hóa hiệu suất của các chức năng. Từ 2 khái niệm trên đây chúng ta có thể rút ra một số nguyên tắc sau dành cho chức năng và quy trình. Principle 1: – Những chức năng cơ bản là những điều không thể thiếu, là nền tảng hoạt động sản xuất của tổ chức. Bất kỳ hoạt động sản xuất nào của tổ chức doanh nghiệp đều gắn liền với chức năng hoặc nhóm chức năng. Đó là đơn vị sản xuất của doanh nghiệp, chất lượng sản phẩm của tổ chức và doanh nghiệp do các bộ phận chức năng này quyết định. Principle 2: – Quy trình là những điều không bắt buộc, nhưng không có nó tất cả chỉ là một sự hỗn tạp. Không có quy trình thì một người thợ giỏi nắm vững các nguyên lý, khi được cung cấp đầy đủ linh kiện của một chiếc ô tô vẫn có thể lắp thành công một chiếc ô tô. Một developer giỏi dù không cần nắm vững quy trình vẫn có thể tự mình code ra được một sản phẩm đầy đủ chức năng. Tuy nhiên ở những doanh nghiệp và dự án lớn khi khối lượng công việc tăng lên, số lượng người lớn đồng thời các công việc có liên quan chặt chẽ với nhau nếu không có quy định trước sau, không có người giám sát thì tất cả sẽ chỉ là một mớ hỗn độn. Các bước dễ bị chồng chéo, dẫn tới lãng phí thời gian, tài nguyên… Principle 3: – Quy trình không giúp cho một chức năng chạy tốt hơn, tuy nhiên nó có tác dụng khi kết hợp nhiều chức năng với nhau. Bản chất quy trình là hỗ trợ là sắp xếp thứ tự của các chức năng, nó không có tác dụng làm cho một chức năng chạy tốt hơn. Rất nhiều người nghĩ rằng quy trình sản xuất gắn với tính chất sản xuất nhưng bản chất không phải vậy. Scrum, water fall, kaban, hybrid… hay bất kỳ quy trình phần mềm nào cũng không thể làm một developer code module mã hóa tốt hơn, cũng như không thể làm giảm thiểu số dòng code cần thiết để hoàn thành nó.Tuy nhiên khi module mã hóa đó liên quan tới việc tài liệu mô tả mã hóa cần phải đầy đủ, chính xác, kết quả viết ra cần được test bao giờ, khi nào thì lúc đó quy trình lại đóng vai trò vô cùng quan trọng. Nó đóng vai trò trung gian điều phối giữa các module chức năng công việc trong tổng thể chung, làm cho các bước phối hợp nhịp nhàng, đảm bảo tiến độ và chất lượng của tổng thể cả dự án. Trong lĩnh vực phần mềm chúng ta có thể lấy ví dụ về các chức năng trong quá trình phát triển phần mềm bao gồm: phân tích yêu cầu, thiết kế, phát triển, kiểm thử, bảo trì đó là những yếu tố chức năng tạo nên vòng đời phát triển phần mềm. Tuy nhiên dựa vào từng đặc thù công việc mà chúng ta có sự kết hợp khác nhau tạo ra các quy trình khác nhau. Dù rằng bản chất công việc vẫn là cùng tạo ra một sản phẩm, tuy nhiên tùy từng đặc thù mà có các quy trình khác nhau. Mỗi quy trình có một đặc điểm riêng phát triển cho phù hợp với đặc thù của từng dự án cũng như từng thời kỳ khác nhau. Mô hình cải tiến hoạt động OE là một vòng tròn khép kín thể hiện tính liên tục của hoạt động cải tiến và đổi mới. Tư tưởngcủa nó cũng vô cùng đơn giản với 4 bước lặp lại đó là: Dẫn dắt và kiểm soát hiệu suất của chức năng: Bước đầu tiên của vòng tròn OE bao gồm việc kiểm soát các hoạt động sản xuất của các nhóm chức năng liên qua tới các hoạt động của nhân viên. Nó bao gồm tất cả các nhân tố dẫn dắt, khuyến khích, hỗ trợ con người làm việc hiệu quả hơn. Các nhân tố trong quá trình này bao gồm sự lãnh đạo, đào tạo, làm việc nhóm, mối quan hệ giữa các cá nhân… Đo đạc và phát triển quy trình làm việc hiệu quả: Bước tiếp theo trong công việc tăng OE đó chính là dựa vào đặc thù công việc để áp dụng đúng quy trình cần thiết. Từ đó đo đạc, đánh giá, lượng hóa các yếu tố phù hợp với tổ chức của mình. Không ngừng cải tiến quy trình và năng suất chuyên môn của các chức năng. Nâng cao năng suất và tự động hóa quy trình : Quá trình OE đòi hỏi các tổ chức sau mỗi quá trình ở bước 2 phải luôn tìm ra được một cơ hội để có thể hệ thống hóa tổ chức và tìm ra những cơ hội để tăng chất lượng, sản lượng, hiệu quả thông qua sự tự động hóa quy trình một cách tối ưu. Cải thiện hiệu suất chức năng : Mục tiêu và kết quả cuối cùng của chu trình phát triển OE đó chính là tăng cường hiệu quả của các chức năng. Bởi vì như đã nói, quy trình chỉ là công cụ hỗ trợ, chức năng mới chính là yếu tố then chốt quyết định sự thành công của sản phẩm. Bạn có thể có trong tay một quy trình sản xuất ô tô chuẩn. Nhưng để tạo ra một chiếc ô tô thành công thì quan trọng nhất đó phải là thiết kế, là chất lượng của từng bộ phận cụ thể, là công nghệ áp dụng trên ô tô … Chính vì thế bước cuối cùng là thành quả của quá trình OE chính là việc cải thiện hiệu suất của chức năng. Làm thế nào để ứng dụng OE trong tổ chứcNắm được tư tưởng và các bước làm của OE có lẽ là điều không phải khó, nhưng để áp dụng vào từng trường hợp cụ thể từng tổ chức thì đó là một điều không hề đơn giản. Chúng ta có thể tóm gọn OE với 4 bước, lấy kaizen và innovation làm nền tảng, hướng tới mục tiêu cải thiện hiệu suất của các bộ phận chức năng làm mục đích. Có nhiều cách tiếp cận để có thể tìm hiểu cách áp dụng OE, cách thông thường nhất chính là đi theo từng bước trong chu trình OE, những điều cần làm để có thể áp dụng từng bước hiệu quả. Bước đầu tiên trong quá trình OE đó là bạn cần nắm vững nghiệp vụ, các đặc điểm của các bộ phận chức năng để có thể kiểm soát nó một cách chắc chắn. Ở bước đầu tiên, thường các công ty chú trọng vào việc có các chuyên gia trong từng lĩnh vực, những người am hiểu sâu về nghiệp vụ, chuyên môn phụ trách các chức năng. Bên cạnh đó cần thêm các kỹ năng khác như khả năng lãnh đạo nhóm, lập kế hoạch, đào tạo …, những kiến thức này là những kiến thức nền tảng để một bộ phận hoạt động trơn tru, ổn định. Bước tiếp theo khi đã bước vào quá trình hoạt động đó là đo đạc và phát triển quy trình phù hợp, ở bước này các tổ chức cần áp dụng một số kỹ thuật cụ thể để có thể đưa ra được những số liệu hợp lý. Việc đo lường để lấy số liệu không hề đơn giản, nó chính là chìa khóa quyết định việc cải thiện như thế nào cho phù hợp. Chính vì thế nếu lấy những con số vô nghĩa hoặc không có giá trị sẽ không thể cải thiện được tình hình công việc. Để có thể lấy được những con số đúng thì việc đầu tiên đó chính là đặt câu hỏi đúng, việc đặt câu hỏi này lại xuất phát từ mục tiêu và trọng tâm phát triển của doanh nghiệp, tổ chức. Một số tổ chức thường áp dụng phương pháp six sigma để xác định các vấn đề trọng tâm và cải tiến. Nó bao gồm tất cả các thành phần từ phân tích, kiểm thử, các kỹ thuật đổi mới … Sau khi nắm vững được các điểm cần cải thiện, các điểm dư thừa thì tổ chức cần phải loại bỏ, tổ chức lại quy trình, đưa ra các tool, các phương pháp có thể tự động hóa cao. Ở điểm này cần áp dụng kaizen và innovation triệt để. Tuy nhiên cần phải nắm vững sự khác biệt giữa 2 khái niệm này để tổ chức cho phù hợp. Ví dụ như kaizen có thể áp dụng rộng rãi với tất cả mọi người, tuy nhiên innovation chỉ nên hướng tập trung vào một số đối tượng cụ thể nhất định. Bước cuối cùng trong chu trình của OE đó chính là bước quan trọng nhất nhưng cũng là bước mà nhiều tổ chức yếu nhất. Đó chính là bước tích hợp các bước phía trước vào hoạt động sản xuất tổng thể của tổ chức. Tôi biết có những tổ chức, công ty có những chiến dịch tăng năng suất hoạt động rất hiệu quả ở từng bộ phận, nhưng cuối cùng lại thất bại trong khâu cuối cùng là khâu áp dụng cho hoạt động chung. Có rất nhiều ý kiến đề xuất có rất nhiều sản phẩm cải tiến, nhưng tất cả chỉ dừng lại ở bước cục bộ. Người Nhật khi bắt đầu hoạt động kaizen cũng từng gặp rất nhiều khó khăn trong việc thuyết phục tất cả mọi người đồng lòng thực hiện kaizen. Ở đây cần phải thể hiện tinh thần leadership, thể hiện những yếu tố quyết định có thể khơi gợi sự hăng hái của cả một tập thể. Ở những tổ chức, công ty mà hoạt động phần lớn dựa vào năng lực tri thức như những công ty phần mềm, lĩnh vực thiết kế thì OE có thể được nhìn nhận dưới một góc độ khác. Đó là góc độ hiệu quả của con người. Vì bản thân công việc thành công hay thất bại phần lớn phụ thuộc vào con người chứ không phải nằm ở công cụ là chiếc máy tính. Nếu như thế thì đâu là cốt lõi để phát triển OE, đâu là giá trị đích thực mà các nhà quản trị phải hướng tới trong việc nâng cao hiệu quả sản xuất. Câu trả lời chính nằm ở 4k. 4K bao gồm kỹ năng, kiến thức, kinh nghiệm, khả năng. Đó chính là các yếu tố quyết định tới sự hiệu quả năng suất chuyên môn làm việc của nhân viên. Tất nhiên bên cạnh đó có thể còn có các yếu tố như tâm lý, thái độ … tuy nhiên cốt lõi vẫn nằm ở 4K. Ở lĩnh vực này tôi cảm thấy rằng ở Việt Nam các nhà quản trị chưa thực sự chú trọng về yếu tố con người. Họ không có kế hoạch để phát triển con người một cách phù hợp toàn diện và cũng chưa có nhiều các chương trình để thúc đẩy động lực của nhân viên. Những yếu tố mà các công ty lớn khi làm về công nghệ hoặc những lĩnh vực cần phát huy tính sáng tạo cao luôn luôn nhấn mạnh vào. Đứng dưới góc độ của tri thức, OE có các cấp bậc khác nhau để thể hiện mức độ hiệu quả của một tổ chức bao gồm: Mức độ thô sơ, thiếu hiểu biết : Bước này có nghĩa là cá nhân không có khả năng thực hiện task một cách đáng tin cậy, mức độ này đồng nghĩa với việc sẽ khiến tổ chức lãng phí thời gian, vật chất, tài nguyên đồng thời chất lượng sẽ không được đảm bảo hoặc sản phẩm sẽ được thay thế … Mức độ kiến thức cá nhân : Mức độ này có nghĩa cá nhân có thể hoàn thành tốt các nhiệm vụ được giao một cách đáng tin cậy, các kiến thức cá nhân lúc này có thể dùng để mở rộng lên mức cao hơn trở thành kiến thức hệ thống. Mức độ kiến thức hệ thống : Kiến thức hệ thống là những kiến thức đã được hệ thống hóa lại dưới dạng tài liệu viết ra hoặc giao tiếp với người khác. Nó thường thu được bởi những người có kiến thức tốt, có khả năng hơn người khác. Các kiến thức này có thể giúp đỡ những người khác trong hoạt động sản xuất, đồng thời giúp tổ chức tiết kiệm được thời gian đào tạo. Có thể hiểu nó chính là những dạng guideline, những tài liệu mẫu, những kinh nghiệm được viết lại. Mức độ kiến thức chuẩn : Mức độ kiến thức chuẩn chính là những kiến thức hệ thống nhưng ở mức cao hơn, đó là những kiến thức cho những quy trình chuẩn hóa.Nó cung cấp một mức độ cao hơn trong việc kết hợp các chức năng, tạo nên các sản phẩm chắc chắn và bền vững cũng như có độ tin cậy cao. Mức độ kiến thức nhúng: Những kiến thức nền tảng là những kiến thức chuẩn đã được chuyển hóa thành công cụ, máy móc hoặc chương trình máy tính mà nó có thể giúp tổ chức tự động thực hiện các công việc nghiệp vụ một cách tự động, tốn ít thời gian công sức. Các công cụ, chương trình càng phức tạp, làm được càng nhiều nhiệm vụ thì mức độ hiệu quả đạt được càng cao. Mô hình kiến thức và OE có thể nhìn như hình trên. Vậy hướng tiếp cận của các công ty có hoạt động tri thức cao đó là phải cố gắng bước lên càng cao càng tốt trong thang cấp độ kiến thức, đồng thời có các hoạt động kế thừa sao cho thế hệ kế cận dễ dàng tiếp xúc được kiến thức ở các mức độ cao hơn một cách nhanh chóng và hiệu quả. Đó chính là chìa khóa để có thể tiếp cận công nghệ mới, những kiến thức chuyên sâu, đồng thời tạo sự hứng khởi và sáng tạo ở nhân viên. Ngoài ra các nhà quản trị cũng cần phải nắm được những khía cạnh thuộc tâm lý để có thể tác động tích cực lên các thành viên trong nhóm của mình, thể hiện rõ tinh thần leadership để tạo nên một tập thể gắn kết. Điều này rất quan trọng trong việc thúc đẩy sáng tạo và tạo ra môi trường làm việc chủ động tích cực.","categories":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"tags":[{"name":"productivity","slug":"productivity","permalink":"https://hieunh161.github.io/tags/productivity/"}]},{"title":"The mythical men-day (Phần 1)","slug":"productivity-1","date":"2016-10-17T15:38:01.000Z","updated":"2016-10-23T09:56:57.093Z","comments":true,"path":"2016/10/18/productivity-1/","link":"","permalink":"https://hieunh161.github.io/at/2016/10/18/productivity-1/","excerpt":"Lời nói đầuThế kỷ 21 sẽ là thế kỷ của hội nhập nơi tất cả các quốc gia các tổ chức, các công ty cùng bắt đầu chơi trên một sân khấu lớn, một sân khấu chung, một thế giới phẳng. Những câu chuyện về toàn cầu hóa, về outsourcing là những chủ đề nổi bật trong 2 thập niên gần đây. Trong tiến trình đó có rất nhiều cơ hội mới nhưng đồng thời có vô vàn thách thức và áp lực. Các công ty nước ngoài vào Việt Nam như thổi luồng gió mới với khu vực FDI nhưng nó cũng thách thức các doanh nghiệp nội vốn dĩ quen với làm ăn bao cấp, cơ chế cần phải đổi mới đẩy mạnh các hoạt động cải tiến để có thể đạt được vị trí vững chắc trên thị trường. Theo michael porter , giáo sư đại học Havard và được xem là cha đẻ chiến lược cạnh tranh hiện đại ông đã đề cập tới 2 yếu tố được xem như là xương sống của bất kỳ sự thành công của doanh nghiệp và tổ chức nào đó chính là hoạt động sản xuất hiệu quả (Operation effective – OE) và chiến lược cạnh tranh (Strategy).","keywords":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"text":"Lời nói đầuThế kỷ 21 sẽ là thế kỷ của hội nhập nơi tất cả các quốc gia các tổ chức, các công ty cùng bắt đầu chơi trên một sân khấu lớn, một sân khấu chung, một thế giới phẳng. Những câu chuyện về toàn cầu hóa, về outsourcing là những chủ đề nổi bật trong 2 thập niên gần đây. Trong tiến trình đó có rất nhiều cơ hội mới nhưng đồng thời có vô vàn thách thức và áp lực. Các công ty nước ngoài vào Việt Nam như thổi luồng gió mới với khu vực FDI nhưng nó cũng thách thức các doanh nghiệp nội vốn dĩ quen với làm ăn bao cấp, cơ chế cần phải đổi mới đẩy mạnh các hoạt động cải tiến để có thể đạt được vị trí vững chắc trên thị trường. Theo michael porter , giáo sư đại học Havard và được xem là cha đẻ chiến lược cạnh tranh hiện đại ông đã đề cập tới 2 yếu tố được xem như là xương sống của bất kỳ sự thành công của doanh nghiệp và tổ chức nào đó chính là hoạt động sản xuất hiệu quả (Operation effective – OE) và chiến lược cạnh tranh (Strategy). Trong những năm 1970, 1980 của thế kỷ trước với trái tim là hoạt động sản xuất hiệu quả Nhật Bản đã thách thức các công ty phương tây với các khái niệm như quản lý chất lượng toàn diện (total quality management), liên tục đánh giá cải tiến (benchmarking), sử dụng thời gian hiệu quả (time-based competition), sản xuất tinh gọn (lean production development) … Và với những điều đã làm họ đã từng vượt xa các đối thủ cạnh tranh của mình về mặt OE khiến người Nhật có thể đưa ra các sản phẩm giá rẻ hơn và có chất lượng tuyệt hảo trong cùng thời gian. Nói về chiến lược cho công ty đó là câu chuyện khó, và để định hướng cho một công ty có thể đi đúng hướng thì trách nhiệm phần lớn thuộc về những nhà quản trị cấp cao, những top-level manager, thế nhưng nói về OE thì đó là câu chuyện của cả công ty, nó không chỉ là vấn đề của các nhà quản trị cấp dưới là những nhà quản trị cấp trung (middle-level manager) và cấp cơ sở (first-level manager) mà nó còn là vấn đề của chính các nhân viên. Khi mỗi người có ý thức nhất định về hoạt động sản xuất kinh doanh hiệu quả thì chắc chắn rằng không có lý do gì để công ty đó không đạt hiệu quả cao ít nhất về mặt chất lượng và sản lượng. Những năm gần đây, khi mà lợi thế về nhân công giá rẻ ở Việt Nam đã dần trở nên bão hòa, nền kinh tế phát triển chậm lại vì sự thiếu ổn định vĩ mô. Các lợi thế do tài nguyên thiên nhiên ưu đãi đã dần mất đi thì vấn đề hiệu suất, năng suất công việc của người Việt đã trở thành một vấn đề quan trọng, quyết định tới sự phát triển tương lai của cả đất nước. Khi hội nhập người Việt Nam luôn nghĩ rằng giá rẻ là một lợi thế cạnh tranh, đó là điều đúng, thế nhưng chúng ta không thể lấy đó là niềm tự hào, phải tự hỏi rằng tại sao giá chúng ta lại rẻ. Ở các nước tiên tiến, năng suất lao động của họ cao gấp hơn 100 lần người Việt, ngay cạnh chúng ta các nước như Thái Lan hay Malaysia cũng có năng suất cao hơn chúng ta 20,30 lần. Vậy chúng ta phải đặt câu hỏi rằng, tại sao và tại sao? Các nhà nghiên cứu đã thống nhất rằng, trong thế kỷ 21 khi mà nguồn tài nguyên hóa thạch dần cạn kiệt thì tài nguyên lớn nhất của xã hội sẽ nằm ở con người, xã hội nào phát triển được điều đó đồng nghĩa với việc sẽ chiếm được ưu thế trong tương lai. Giá trị của chất xám là điều không cần bàn cãi khi con người trong thế kỷ 20 đã khám phá ra vô số các phát minh có giá trị thúc đẩy công nghệ và khoa học kỹ thuật. Và chính bản thân các nước phát triển ngày nay cũng đã chứng minh điều đó. Nhật Bản một nước nghèo nàn về tài nguyên nhưng nhờ đầu tư khoa học kỹ thuật con người đã trở thành siêu cường của thế kỷ 20, Mỹ với triết lý tự do, khuyến khích sự sáng tạo vẫn luôn đi đầu trong tất cả các lĩnh vực then chốt của nhân loại trong thế kỷ qua. Hàn Quốc một quốc gia nghèo nàn về tài nguyên so với người anh em Triều Tiên của mình nhưng lại có nền khoa học phát triển vượt bậc, có các công ty lớn nhất thế giới như Samsung, huyndai, tất cả dựa vào yếu tố con người. Trong chuyên đề tìm hiểu về hoạt động kinh doanh sản xuất này, tôi muốn đi tìm những điều ẩn chứa đằng sau thành công của quá trình hoạt động sản xuất hiệu quả. Những yếu tố làm tăng năng suất lao động, những điều có thể áp dụng và thay đổi một tổ chức để có thể thúc đẩy một tổ chức đi tới thành công. Đó có thể chỉ là những yếu tố rất nhỏ, những điều tôi lượm lặt được trên con đường tích lũy tri thức của bản thân mình, đó có thể là những lời khuyên từ những chuyên gia, những điều đến từ các kết quả nghiên cứu của các tổ chức trên thế giới. Thế nhưng dù nó là cái gì thì đó cũng là những điều tôi tin rằng sẽ góp phần tăng hoạt động hiệu quả của các tổ chức, ít nhất là trong lĩnh vực công nghệ thông tin, lĩnh vực tôi đang làm việc. Kaizen vs innovationTrong lĩnh vực sản xuất, mục đích của các công ty luôn làm sao để có thể tối ưu hóa hoạt động của mình để có thể đạt được chất lượng tốt nhất và đồng thời đạt được sản lượng cao nhất. Một công ty chỉ có thể vượt trên đối thủ của mình nếu họ có thể đạt được sự khác biệt và bảo tồn được sự khác biệt đấy. Đồng thời họ phải cung cấp được cho người dùng sản phẩm với giá trị cao hơn đối thủ hoặc chí ít ở một mức cạnh tranh được đồng thời phải ở một cái giá thấp nhất có thể. Đó là một mối tổng thể kết hợp của rất nhiều các khâu các yếu tố từ không chỉ từ các khâu cơ bản nghiên cứu, chế tạo, bán, phân phối sản phẩm hoặc dịch vụ, mà đó còn là từ chăm sóc khách hàng, đào tạo nhân viên, tạo ra những giá trị thặng dư ngoài sản phẩm…Trong lĩnh vực IT một ví dụ nổi tiếng về sự khác biệt quá nổi tiếng mà bất kỳ ai cũng có thể nhận ra đó là ví dụ của Apple. Quả táo khuyết đã quyết định đi theo con đường riêng của mình ngay từ những ngày đầu với hệ điều hành MAC. Và chính điều đó đã làm nên sự đọc đáo của apple mà không một công ty nào có thể bắt trước được. Với apple đó không chỉ là những sản phẩm tuyệt vời, nó còn là duy nhất. Họ đã thành công với triết lý tạo nên sự khác biệt và mang đến cho người dùng không chỉ sản phẩm mà trên đó nữa đó là sự trải nghiệm. Câu chuyện OE là một câu chuyện rất dài, nó đi theo xuyên suốt chiều dài của sản xuất, kinh doanh từ khi con người biết cách chuyển lao động hái lượm săn bắt về trồng trọt. Qua quá trình lao động họ không những tìm ra những điều mới mà họ còn phải cố gắng giảm thiểu những sự lãng phí …Ngày nay nó gắn với bất kỳ hoạt động nào mà cho phép các công ty tổ chức tận dụng tối đa các tài nguyên đầu vào, giảm thiểu các lỗi trên sản phẩm, trong sản xuất, phát triển sản phẩm tốt hơn và nhanh hơn. Quá trình này rất đa dạng và mỗi tổ chức đều tìm cho mình một cách khác nhau để thực hiện nó, có những công ty cố gắng giảm thiểu sự lãng phí để có thể cho ra nhiều sản phẩm hơn với lượng đầu vào đã có, có những công ty cố gắng ứng dụng nhiều công nghệ hơn, có những công ty cố gắng tạo động lực lớn hơn cho nhân viên của mình, có những công ty lại cố gắng tập trung vào việc quản lý chặt chẽ để đưa ra một quy trình tối ưu hơn …Tất cả các quá trình đó với một mục đích cuối cùng là tạo ra những sản phẩm tuyệt vời với giá cả thấp nhất. Người Nhật nổi tiếng với hoạt động kaizen còn Mỹ và phương tây nổi tiếng với khái niệm innovation. Cả hai thuật ngữ đều ám chỉ các hoạt động dùng để cả thiện hoạt động sản xuất của doanh nghiệp. Vậy có điểm gì khác nhau giữa hai khái niệm này. Trong tiếng anh kaizen được dịch là continuous improvement, một cách đơn giản chúng ta có thể hiểu rằng kaizen(改善) là hoạt động cải tiến liên tục dựa vào việc nhận ra các vấn đề của công việc, cải tiến, áp dụng vào thực tế. Lặp đi lặp lại liên tục để không ngừng gia tăng hiệu quả công việc. Innovation là đổi mới, nghĩa là áp dụng các cách thức thay đổi lớn mang tính nhảy vọt nhằm đạt được được bước nhảy vọt về chất lượng của như sản lượng. Một cách mô hình chúng ta có thể hiểu kaizen của người Nhật như là một chú rùa lầm lũi cần mẫn và không ngừng bước tới, còn đối với innovation của phương tây như là một chú thỏ, có thể bước những bước rất dài để tới đích. Chúng ta có thể hình dung Kaizen như là một quá trình đi lên không ngừng nghỉ, còn innovation là một quá trình bậc thang, thay đổi theo các bậc. như hình dưới đây. Kaizen có ảnh hưởng trong dài hạn và tồn tại lâu tuy nhiên ảnh hưởng của nó thường không bao giờ quá lớn. Còn đối với innovation nó xảy ra trong thời gian ngắn tuy nhiên ảnh hưởng lại vô cùng mạnh mẽ. Sức mạnh của kaizen nằm ở việc liên tục cải tiến, tuy từ từ từng chút một nhưng nó ổn định. Đồng thời có sự tham gia của tất cả các thành phần trong tổ chức, từ cấp quản lý cho tới từng nhân viên. Chính vì thế khi áp dụng kaizen kết quả thu được luôn là một tập thể mạnh. Ngược lại với innovation, nó là quá trình xảy ra đứt quãng, thay đổi mạnh mẽ, tuy nhiên nó thường xuất phát từ một vài cá nhân giỏi kiệt xuất với những ý tưởng mới mẻ như là những mũi nhọn và dần dần lan ra rộng khắp trong tổ chức. Tuy nhiên đôi khi đổi mới không phải xuất phát từ sự tự phát mà nó xuất phát từ tình thế cần phải yêu cầu sự thay đổi. Ví dụ như sau một thời gian dài làm việc, chất lượng đi xuống, nhân viên bắt đầu thiếu động lực…hay bị các đối thủ cạnh tranh vượt lên trong cuộc đua thị phần, chất lượng. Lúc này các nhà quản lý mới thấy cần có sự thay đổi và họ bắt đầu cải tiến. Vì thế các tổ chức áp dụng innovation trong các giai đoạn tái cấu trúc, hoặc khi có cần sự đột phá cao để đạt được các mục tiêu lớn. Còn hoạt động kaizen luôn hướng tới việc phát triển bền vững. Cũng do đặc thù cần có sự đột phá lớn nên các hoạt động innovation luôn cần có một sự đột phá về mặt công nghệ, một lý thuyết mới hay một phát minh mới. Ngược lại quá trình kaizen nhấn mạnh vào kỹ năng làm việc, vào các kiến thức hàng ngày, và một nền tảng tri thức tích lũy. Hoạt động kaizen nhấn mạnh vào yếu tố con người, thông qua lao động sản xuất hàng ngày để đạt được kết quả cao. Còn bản thân innovation nhấn mạnh vào yếu tố công nghệ, lấy công nghệ làm trung tâm là yếu tố then chốt để tổ chức vươn mình đi trước các đối thủ. Cũng chính từ những đặc điểm này mà hoạt động kaizen phù hợp với một thị trường phát triển không quá nhanh, một nền kinh tế ổn định. Còn bản thân innovation là hoạt động mang tính đột phá, nó phù hợp với một nền kinh tế tăng trưởng nhanh và năng động. Michael porter cũng đã nhắc tới yếu tố này trong cuốn sách của ông với việc nhấn mạnh các công ty Nhật sau một thời gian đi đầu trong các lĩnh vực đang dần trở nên chậm chạp và bị các công ty phương Tây vượt lên trong một nền kinh tế phẳng nơi mà yếu tố chiến lược và đổi mới là những yếu tố quyết định sự thành công. Bản thân phương tây cũng học được rất nhiều điều từ khái niệm kaizen của người Nhật, đến mức hiện tại kaizen đã trở thành một từ xuất hiện trong từ điển tiếng anh với khái niệm cải tiến trong hoạt động sản xuất. Với các nghiên cứu về hoạt động kaizen của người Nhật, phương tây cũng đã thu được rất nhiều kinh nghiệm quý báu. Những cuốn sách như toyota way, how to do kaizen, kaizen guide … lần lượt là những cuốn sách best seller và đã được phương tây đón nhận nồng nhiệt. Ở Việt Nam có cuốn sách kaizen teian được Hiệp hội con người Nhật Bản giới thiệu đã được dịch sang tiếng Việt cũng là một cuốn sách hay về kaizen. Ở khía cạnh ngược lại, người Nhật sau một thời gian dài thụt lùi đã nhận ra rằng họ cần phải thay đổi, với các phương thức cũ đã không thể giữ họ ở vị trí đỉnh cao của thế giới và họ cũng đang dần chuyển mình. Họ nhận ra rằng họ phải đổi mới nhiều hơn để có thể có những sản phẩm đỉnh cao như trước đây họ đã có. Dần dần các doanh nghiệp, các tổ chức hiện đại dung hòa hai khái niệm này và đưa ra một mô hình phát triển hoàn thiện hơn cho doanh nghiệp của mình như hình trên, đó là sự kết hợp giữa kaizen và innovation, đó là một mô hình giúp các doanh nghiệp có thể đạt được sự phát triển bền vững và ổn định dựa vào cả hai mũi nhọn. Tối ưu hóa hoạt động sản xuất và nhảy vọt nhờ vào sáng tạo công nghệ. Các nhà nghiên cứu cũng chỉ ra rằng trong chuỗi sản xuất sản phẩm thì sẽ có những giai đoạn cần thiên hướng và đổi mới và có những giai đoạn cần phải tập trung tối đa vào kaizen. Ví dụ như những giai đoạn cần hiệu quả cao trong tổ chức, thực hành như hoạt động tại các công xưởng, nhà máy thì lúc này các nhà quản trị cần phải tối ưu hóa vào việc tổ chức các hoạt động kaizen. Các số liệu của các công ty Nhật đã cho thấy rằng, trung bình những công ty hoạt động kaizen hiệu quả 1 năm trung bình mỗi người có khoảng hàng chục kaizen giúp doanh nghiệp hoạt động hiệu quả hơn. Người Nhật luôn có suy nghĩ tích tiểu thành đại, ví dụ mỗi người tiết kiệm được 5 phút/ngày thì cả doanh nghiệp 1000 người có thể tiết kiệm được 5000 phút/ngày = 10 ngày làm việc, 1 năm sẽ tiết kiệm được 2000 ngày công, đó là một con số không hề nhỏ. Thế nên mỗi sáng kiến kaizen chỉ cần tiết kiệm được 1 phút thì đó là một con số khổng lồ. Ngược lại có những hoạt động đòi hỏi tính đối mới sáng tạo cao. Như các hoạt động nghiên cứu sản phẩm mới, các hoạt động mang tính ý tưởng chiến lược, thì lúc đó cần phát huy tối đa tính sáng tạo của nhân viên. Hiện nay ở lĩnh vực công nghiệp phần mềm có thể chia làm 2 lĩnh vực chính là sản xuất sản phẩm như vinagame hay outsourcing như Fsoft thì với mỗi công ty đặc thù cần phải nhấn mạnh vào những khía cạnh khác nhau. Các công ty tự sản xuất sản phẩm thường phải có tỷ lệ đổi mới/cải tiến là 7/3 và với các công ty gia công phần mềm là ngược lại 3/7. Bởi vì bản thân gia công phần mềm tính chất đổi mới bị hạn chế rất nhiều do phần lớn các công nghệ, các yêu cầu tới từ phía đối tác, các khách hàng nước ngoài, và việc lớn nhất các công ty phần mềm gia công cần làm đó là làm thế nào để đưa ra sản phẩm với chất lượng tốt nhất dựa vào những yêu cầu cụ thể đó. Ngược lại các công ty tự sản xuất cần phải áp dụng các công nghệ mới nhất tốt nhất để có thể đưa ra những sản phẩm có tính cạnh tranh cao trong thị trường IT khắc nghiệt. Nhưng dù thế nào đi nữa thì các hoạt động để cải tiến, cải tiến và không ngừng nâng cao luôn là điều bắt buộc nếu một công ty một tổ chức muốn giữ vị thế cạnh tranh của mình trước các đối thủ bám đuôi phía sau. Muốn cho công ty liên tục tồn tại và phát triển trường tồn thì đây sẽ là kim chỉ nam để các công ty hướng tới. Không ngừng hoàn thiện, cải tiến và phát triển. Đó có thể là bất cứ yếu tố nào mang lại hiệu ứng tích cực cho công ty ví dụ như cải tiến trong sản xuất, trong phương pháp làm việc, cũng như là cải tiến trong văn hóa, trong ứng xử để gắn kết nhân viên với nhau cũng như công ty với nhân viên.…","categories":[{"name":"production","slug":"production","permalink":"https://hieunh161.github.io/categories/production/"}],"tags":[{"name":"productivity","slug":"productivity","permalink":"https://hieunh161.github.io/tags/productivity/"}]}]}